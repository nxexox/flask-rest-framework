{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Rest Framework Python Rest Framework is a full-fledged rest api engine. You can concentrate all your strength on business logic, take care of the rest of the Python Rest Framework. Full documentation for the project is available at [https://nxexox.github.io/python-rest-framework/][docs]. Requirements Python (3.4, 3.5, 3.6, 3.7) six Installation Install using pip , including any optional packages you want\u2026 pip install python-rest-framework \u2026or clone the project from github. git clone git@github.com:nxexox/python-rest-framework.git Example For example, we will serialize the data from the request object. First we write the serializer from rest_framework.serializers import ( Serializer, CharField, IntegerField, ListField, FloatField ) # Example serializer for parsing body data from web request. class ExampleSerializer(Serializer): char_field = CharField(label='This char field', required=True) int_field = IntegerField(label='This int field', required=True) list_float_field = ListField(child=FloatField(), required=True, min_length=2) Now we process the request body with a serializer # web request data data = { 'char_field': 'example', 'int_field': 1, 'list_float_field': [1.0, 1.1, 1.2] } ser = ExampleSerializer(data=data) if ser.is_valid(): print(ser.validated_data) else: print(ser.errors)","title":"Home"},{"location":"#python-rest-framework","text":"Python Rest Framework is a full-fledged rest api engine. You can concentrate all your strength on business logic, take care of the rest of the Python Rest Framework. Full documentation for the project is available at [https://nxexox.github.io/python-rest-framework/][docs].","title":"Python Rest Framework"},{"location":"#requirements","text":"Python (3.4, 3.5, 3.6, 3.7) six","title":"Requirements"},{"location":"#installation","text":"Install using pip , including any optional packages you want\u2026 pip install python-rest-framework \u2026or clone the project from github. git clone git@github.com:nxexox/python-rest-framework.git","title":"Installation"},{"location":"#example","text":"For example, we will serialize the data from the request object. First we write the serializer from rest_framework.serializers import ( Serializer, CharField, IntegerField, ListField, FloatField ) # Example serializer for parsing body data from web request. class ExampleSerializer(Serializer): char_field = CharField(label='This char field', required=True) int_field = IntegerField(label='This int field', required=True) list_float_field = ListField(child=FloatField(), required=True, min_length=2) Now we process the request body with a serializer # web request data data = { 'char_field': 'example', 'int_field': 1, 'list_float_field': [1.0, 1.1, 1.2] } ser = ExampleSerializer(data=data) if ser.is_valid(): print(ser.validated_data) else: print(ser.errors)","title":"Example"},{"location":"release-notes/","text":"Release Notes Versioning Minor version numbers (0.0.x) are used for changes that are API compatible. You should be able to upgrade between minor point releases without any other code changes. Medium version numbers (0.x.0) may include API changes, in line with the [deprecation policy][deprecation-policy]. You should read the release notes carefully before upgrading between medium point releases. Major version numbers (x.0.0) are reserved for substantial project milestones. 0.1.4 Date : [25th October 2018]. Add JsonField , DictField Add SerializerMethodField 0.1.3 Date : [17th October 2018]. Add DateField , TimeField , DateTimeField . Translate full project to english. child on ListField not required by default. 0.1.2 Date : [10th October 2018]. Init serializers, fields, validators, docs, tests. Push to Open Source community.","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#versioning","text":"Minor version numbers (0.0.x) are used for changes that are API compatible. You should be able to upgrade between minor point releases without any other code changes. Medium version numbers (0.x.0) may include API changes, in line with the [deprecation policy][deprecation-policy]. You should read the release notes carefully before upgrading between medium point releases. Major version numbers (x.0.0) are reserved for substantial project milestones.","title":"Versioning"},{"location":"release-notes/#014","text":"Date : [25th October 2018]. Add JsonField , DictField Add SerializerMethodField","title":"0.1.4"},{"location":"release-notes/#013","text":"Date : [17th October 2018]. Add DateField , TimeField , DateTimeField . Translate full project to english. child on ListField not required by default.","title":"0.1.3"},{"location":"release-notes/#012","text":"Date : [10th October 2018]. Init serializers, fields, validators, docs, tests. Push to Open Source community.","title":"0.1.2"},{"location":"api-guid/fields/","text":"Fields Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects. Note: The serializer fields are declared in fields.py , but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName> . Core arguments Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted: - required Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization. Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation. Defaults to True . - default If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all. May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. When serializing the instance, default will be used if the the object attribute or dictionary key is not present in the instance. Note that setting a default value implies that the field is not required. Enabling the arguments of the default keyword will set the required to False . - label A short text string that may be used as the name of the field in HTML form fields or other descriptive elements. - validators A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should raise serializers.ValidationError . - error_messages A dictionary of error codes to error messages. Fields - BooleanField A boolean representation that also accepts None as a valid value. When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False , even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input. Signature: BooleanField() - CharField A text representation. Optionally validates the text to be shorter than max_length and longer than min_length . Signature: CharField(max_length=None, min_length=None, trim_whitespace=True, allow_blank=False) min_length - Validates that the input contains no fewer than this number of characters. max_length - Validates that the input contains no more than this number of characters. allow_blank - If set to True then the empty string should be considered a valid value. If set to False then the empty string is considered invalid and will raise a validation error. Defaults to False . trim_whitespace - If set to True then leading and trailing whitespace is trimmed. Defaults to True . - IntegerField An integer representation. Signature : IntegerField(min_value=None, max_value=None) min_value Validate that the number provided is no less than this value. max_value Validate that the number provided is no greater than this value. - FloatField A floating point representation. Signature : FloatField(min_value=None, max_value=None) min_value Validate that the number provided is no less than this value. max_value Validate that the number provided is no greater than this value. Date and time fields - DateTimeField A date and time representation. Signature: DateTimeField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_DATETIME_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python datetime objects should be returned by to_representation . In this case the datetime encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_DATETIME_FORMAT setting will be used, which defaults to 'iso-8601' . DateTimeField format strings. Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29 12:34:56' ) When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class. - DateField A date representation. Signature: DateField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_DATE_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python date objects should be returned by to_representation . In this case the date encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_DATE_FORMATS setting will be used, which defaults to 'iso-8601' . DateField format strings Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style dates should be used. (eg '2013-01-29' ) - TimeField A time representation. Signature: TimeField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_TIME_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python time objects should be returned by to_representation . In this case the time encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_TIME_FORMATS setting will be used, which defaults to 'iso-8601' . TimeField format strings Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style times should be used. (eg '12:34:56' ) Composite fields - ListField A field class that validates a list of objects. Signature : ListField(child=<A_FIELD_INSTANCE>, min_length=None, max_length=None, allow_empty=False) child - A field instance that should be used for validating the objects in the list. If this argument is not provided then objects in the list will not be validated. min_length - Validates that the list contains no fewer than this number of elements. max_length - Validates that the list contains no more than this number of elements. allow_blank - If set to True , an empty array should be considered valid. If set to False , an empty array is considered invalid and causes a validation error. The default is False . For example, to validate a list of integers you might use something like the following: scores = serializers.ListField( child=serializers.IntegerField(min_value=0, max_value=100) ) The ListField class also supports a declarative style that allows you to write reusable list field classes. class StringListField(serializers.ListField): child = serializers.CharField() We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it. - JSONField A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings. Signature : JSONField() - DictField A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values. Signature : DictField(child=<A_FIELD_INSTANCE>) child - A field instance that should be used for validating the values in the dictionary. If this argument is not provided then values in the mapping will not be validated. For example, to create a field that validates a mapping of strings to strings, you would write something like this: document = DictField(child=CharField()) You can also use the declarative style, as with ListField . For example: class DocumentField(DictField): child = CharField() Miscellaneous fields - SerializerMethodField It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object. Signature : SerializerMethodField(method_name_get=None, method_name_pop=None) method_name_get - The name of the method on the calling serializer during object scrapping. If not included this defaults to get_<field_name> . method_name_pop - The name of the method on the calling serializer during validation data. If not included this defaults to pop_<field_name> . The serializer method referred to by the method_name_get argument should accept a single argument (in addition to self ), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example: from datetime.datetime import now from rest_framework import serializers class UserSerializer(serializers.Serializer): days_since_joined = serializers.SerializerMethodField() def get_days_since_joined(self, obj): return (now() - obj.date_joined).days The serializer method referenced by the method_name_pop argument must take one argument (in addition to self ), which is the value to process and validate. It must return whatever you want to include in the validated view of the data. For example: from datetime.datetime import now from rest_framework import serializers class UserSerializer(serializers.Serializer): rgb = serializers.SerializerMethodField() def pop_rgb(self, data): return data.split(';')[1:3] Custom fields If you want to create a custom field, you\u2019ll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date / time / datetime or None . They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using. The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype. The to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid. Examples A Basic Custom Field Let\u2019s look at an example of serializing a class that represents an RGB color value: class Color(object): \"\"\" A color represented in the RGB colorspace. \"\"\" def __init__(self, red, green, blue): assert(red >= 0 and green >= 0 and blue >= 0) assert(red < 256 and green < 256 and blue < 256) self.red, self.green, self.blue = red, green, blue class ColorField(serializers.Field): \"\"\" Color objects are serialized into 'rgb(#, #, #)' notation. \"\"\" def to_representation(self, value): return \"rgb(%d, %d, %d)\" % (value.red, value.green, value.blue) def to_internal_value(self, data): data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] return Color(red, green, blue) By default field values are treated as mapping to an attribute on the object or key Mapping collection. If you need to customize how the field value is accessed and set you need to override .get_attribute() . As an example, let\u2019s create a field that can be used to represent the class name of the object being serialized: class ClassNameField(serializers.Field): def get_attribute(self, instance): # We pass the object instance onto `to_representation`, # not just the field attribute. return instance def to_representation(self, value): \"\"\" Serialize the value's class name. \"\"\" return value.__class__.__name__ Raising validation errors Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError , like so: def to_internal_value(self, data): if not isinstance(data, six.text_type): msg = 'Incorrect type. Expected a string, but got %s' raise ValidationError(msg % type(data).__name__) if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data): raise ValidationError('Incorrect format. Expected `rgb(#,#,#)`.') data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] if any([col > 255 or col < 0 for col in (red, green, blue)]): raise ValidationError('Value out of range. Must be between 0 and 255.') return Color(red, green, blue) The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example: default_error_messages = { 'incorrect_type': 'Incorrect type. Expected a string, but got {input_type}', 'incorrect_format': 'Incorrect format. Expected `rgb(#,#,#)`.', 'out_of_range': 'Value out of range. Must be between 0 and 255.' } def to_internal_value(self, data): if not isinstance(data, six.text_type): self.fail('incorrect_type', input_type=type(data).__name__) if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data): self.fail('incorrect_format') data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] if any([col > 255 or col < 0 for col in (red, green, blue)]): self.fail('out_of_range') return Color(red, green, blue) This style keeps your error messages cleaner and more separated from your code, and should be preferred.","title":"Serializer fields"},{"location":"api-guid/fields/#fields","text":"Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects. Note: The serializer fields are declared in fields.py , but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName> .","title":"Fields"},{"location":"api-guid/fields/#core-arguments","text":"Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:","title":"Core arguments"},{"location":"api-guid/fields/#-required","text":"Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization. Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation. Defaults to True .","title":"- required"},{"location":"api-guid/fields/#-default","text":"If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all. May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. When serializing the instance, default will be used if the the object attribute or dictionary key is not present in the instance. Note that setting a default value implies that the field is not required. Enabling the arguments of the default keyword will set the required to False .","title":"- default"},{"location":"api-guid/fields/#-label","text":"A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.","title":"- label"},{"location":"api-guid/fields/#-validators","text":"A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should raise serializers.ValidationError .","title":"- validators"},{"location":"api-guid/fields/#-error_messages","text":"A dictionary of error codes to error messages.","title":"- error_messages"},{"location":"api-guid/fields/#fields_1","text":"","title":"Fields"},{"location":"api-guid/fields/#-booleanfield","text":"A boolean representation that also accepts None as a valid value. When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False , even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input. Signature: BooleanField()","title":"- BooleanField"},{"location":"api-guid/fields/#-charfield","text":"A text representation. Optionally validates the text to be shorter than max_length and longer than min_length . Signature: CharField(max_length=None, min_length=None, trim_whitespace=True, allow_blank=False) min_length - Validates that the input contains no fewer than this number of characters. max_length - Validates that the input contains no more than this number of characters. allow_blank - If set to True then the empty string should be considered a valid value. If set to False then the empty string is considered invalid and will raise a validation error. Defaults to False . trim_whitespace - If set to True then leading and trailing whitespace is trimmed. Defaults to True .","title":"- CharField"},{"location":"api-guid/fields/#-integerfield","text":"An integer representation. Signature : IntegerField(min_value=None, max_value=None) min_value Validate that the number provided is no less than this value. max_value Validate that the number provided is no greater than this value.","title":"- IntegerField"},{"location":"api-guid/fields/#-floatfield","text":"A floating point representation. Signature : FloatField(min_value=None, max_value=None) min_value Validate that the number provided is no less than this value. max_value Validate that the number provided is no greater than this value.","title":"- FloatField"},{"location":"api-guid/fields/#date-and-time-fields","text":"","title":"Date and time fields"},{"location":"api-guid/fields/#-datetimefield","text":"A date and time representation. Signature: DateTimeField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_DATETIME_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python datetime objects should be returned by to_representation . In this case the datetime encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_DATETIME_FORMAT setting will be used, which defaults to 'iso-8601' .","title":"- DateTimeField"},{"location":"api-guid/fields/#datetimefield-format-strings","text":"Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29 12:34:56' ) When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.","title":"DateTimeField format strings."},{"location":"api-guid/fields/#-datefield","text":"A date representation. Signature: DateField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_DATE_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python date objects should be returned by to_representation . In this case the date encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_DATE_FORMATS setting will be used, which defaults to 'iso-8601' .","title":"- DateField"},{"location":"api-guid/fields/#datefield-format-strings","text":"Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style dates should be used. (eg '2013-01-29' )","title":"DateField format strings"},{"location":"api-guid/fields/#-timefield","text":"A time representation. Signature: TimeField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_TIME_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python time objects should be returned by to_representation . In this case the time encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_TIME_FORMATS setting will be used, which defaults to 'iso-8601' .","title":"- TimeField"},{"location":"api-guid/fields/#timefield-format-strings","text":"Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style times should be used. (eg '12:34:56' )","title":"TimeField format strings"},{"location":"api-guid/fields/#composite-fields","text":"","title":"Composite fields"},{"location":"api-guid/fields/#-listfield","text":"A field class that validates a list of objects. Signature : ListField(child=<A_FIELD_INSTANCE>, min_length=None, max_length=None, allow_empty=False) child - A field instance that should be used for validating the objects in the list. If this argument is not provided then objects in the list will not be validated. min_length - Validates that the list contains no fewer than this number of elements. max_length - Validates that the list contains no more than this number of elements. allow_blank - If set to True , an empty array should be considered valid. If set to False , an empty array is considered invalid and causes a validation error. The default is False . For example, to validate a list of integers you might use something like the following: scores = serializers.ListField( child=serializers.IntegerField(min_value=0, max_value=100) ) The ListField class also supports a declarative style that allows you to write reusable list field classes. class StringListField(serializers.ListField): child = serializers.CharField() We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.","title":"- ListField"},{"location":"api-guid/fields/#-jsonfield","text":"A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings. Signature : JSONField()","title":"- JSONField"},{"location":"api-guid/fields/#-dictfield","text":"A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values. Signature : DictField(child=<A_FIELD_INSTANCE>) child - A field instance that should be used for validating the values in the dictionary. If this argument is not provided then values in the mapping will not be validated. For example, to create a field that validates a mapping of strings to strings, you would write something like this: document = DictField(child=CharField()) You can also use the declarative style, as with ListField . For example: class DocumentField(DictField): child = CharField()","title":"- DictField"},{"location":"api-guid/fields/#miscellaneous-fields","text":"","title":"Miscellaneous fields"},{"location":"api-guid/fields/#-serializermethodfield","text":"It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object. Signature : SerializerMethodField(method_name_get=None, method_name_pop=None) method_name_get - The name of the method on the calling serializer during object scrapping. If not included this defaults to get_<field_name> . method_name_pop - The name of the method on the calling serializer during validation data. If not included this defaults to pop_<field_name> . The serializer method referred to by the method_name_get argument should accept a single argument (in addition to self ), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example: from datetime.datetime import now from rest_framework import serializers class UserSerializer(serializers.Serializer): days_since_joined = serializers.SerializerMethodField() def get_days_since_joined(self, obj): return (now() - obj.date_joined).days The serializer method referenced by the method_name_pop argument must take one argument (in addition to self ), which is the value to process and validate. It must return whatever you want to include in the validated view of the data. For example: from datetime.datetime import now from rest_framework import serializers class UserSerializer(serializers.Serializer): rgb = serializers.SerializerMethodField() def pop_rgb(self, data): return data.split(';')[1:3]","title":"- SerializerMethodField"},{"location":"api-guid/fields/#custom-fields","text":"If you want to create a custom field, you\u2019ll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date / time / datetime or None . They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using. The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype. The to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.","title":"Custom fields"},{"location":"api-guid/fields/#examples","text":"","title":"Examples"},{"location":"api-guid/fields/#a-basic-custom-field","text":"Let\u2019s look at an example of serializing a class that represents an RGB color value: class Color(object): \"\"\" A color represented in the RGB colorspace. \"\"\" def __init__(self, red, green, blue): assert(red >= 0 and green >= 0 and blue >= 0) assert(red < 256 and green < 256 and blue < 256) self.red, self.green, self.blue = red, green, blue class ColorField(serializers.Field): \"\"\" Color objects are serialized into 'rgb(#, #, #)' notation. \"\"\" def to_representation(self, value): return \"rgb(%d, %d, %d)\" % (value.red, value.green, value.blue) def to_internal_value(self, data): data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] return Color(red, green, blue) By default field values are treated as mapping to an attribute on the object or key Mapping collection. If you need to customize how the field value is accessed and set you need to override .get_attribute() . As an example, let\u2019s create a field that can be used to represent the class name of the object being serialized: class ClassNameField(serializers.Field): def get_attribute(self, instance): # We pass the object instance onto `to_representation`, # not just the field attribute. return instance def to_representation(self, value): \"\"\" Serialize the value's class name. \"\"\" return value.__class__.__name__","title":"A Basic Custom Field"},{"location":"api-guid/fields/#raising-validation-errors","text":"Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError , like so: def to_internal_value(self, data): if not isinstance(data, six.text_type): msg = 'Incorrect type. Expected a string, but got %s' raise ValidationError(msg % type(data).__name__) if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data): raise ValidationError('Incorrect format. Expected `rgb(#,#,#)`.') data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] if any([col > 255 or col < 0 for col in (red, green, blue)]): raise ValidationError('Value out of range. Must be between 0 and 255.') return Color(red, green, blue) The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example: default_error_messages = { 'incorrect_type': 'Incorrect type. Expected a string, but got {input_type}', 'incorrect_format': 'Incorrect format. Expected `rgb(#,#,#)`.', 'out_of_range': 'Value out of range. Must be between 0 and 255.' } def to_internal_value(self, data): if not isinstance(data, six.text_type): self.fail('incorrect_type', input_type=type(data).__name__) if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data): self.fail('incorrect_format') data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] if any([col > 255 or col < 0 for col in (red, green, blue)]): self.fail('out_of_range') return Color(red, green, blue) This style keeps your error messages cleaner and more separated from your code, and should be preferred.","title":"Raising validation errors"},{"location":"api-guid/serializers/","text":"Serializers Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON , XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data. Declaring Serializers Let\u2019s start by creating a simple object we can use for example: from datetime import datetime class Comment(object): def __init__(self, author_name, content, created=False): self.author_name = author_name self.content = content self.created = bool(created) comment = Comment(author_name='example_name', content='foo bar') We\u2019ll declare a serializer that we can use to serialize and deserialize data that corresponds to Comment objects. from rest_framework import serializers class CommentSerializer(serializers.Serializer): author_name = serializers.CharField(required=True) content = serializers.CharField(max_length=200) created = serializers.BooleanField(required=True) Serializing objects We can now use CommentSerializer to serialize a comment, or list of comments. serializer = CommentSerializer(comment) serializer.data # {'author_name': 'example_name', 'content': 'foo bar', 'created': False} At this point we\u2019ve translated the model instance into Python native datatypes. To finalise the serialization process we render the data into json . from rest_framework.renderers import JSONRenderer json = JSONRenderer().render(serializer.data) json # b'{\"author_name\":\"example\",\"content\":\"foo bar\",\"created\":false}' Deserializing objects Deserialization is similar. First we parse a stream into Python native datatypes\u2026 import io from rest_framework.parsers import JSONParser stream = io.BytesIO(json) data = JSONParser().parse(stream) \u2026then we restore those native datatypes into a dictionary of validated data. serializer = CommentSerializer(data=data) serializer.is_valid() # True serializer.validated_data # {'content': 'foo bar', 'author_name': 'example', 'created': False)} Validation When deserializing data, you always need to call is_valid() before attempting to access the validated data. If any validation errors occur, the .errors property will contain a dictionary representing the resulting error messages. For example: serializer = CommentSerializer(data={'author_name': 'foobar', 'content': 'baz'}) serializer.is_valid() # False serializer.errors # {'author_name': [u'This field is required.'], 'created': [u'This field is required.']} Each key in the dictionary will be the field name, and the values will be lists of strings of any error messages corresponding to that field. The non_field_errors key may also be present, and will list any general validation errors. When deserializing a list of items, errors will be returned as a list of dictionaries representing each of the deserialized items. Raising an exception on invalid data The .is_valid() method takes an optional raise_exception flag that will cause it to raise a serializers.ValidationError exception if there are validation errors. try: serializer.is_valid(raise_exception=True) except ValidationError: print(serializer.errors) Field-level validation You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. These methods take a single argument, which is the field value that requires validation. Your validate_<field_name> methods should return the validated value or raise a serializers.ValidationError . For example: from rest_framework import serializers class BlogPostSerializer(serializers.Serializer): title = serializers.CharField(max_length=100) content = serializers.CharField() def validate_title(self, value): \"\"\" Check that the blog post is about Django. \"\"\" if 'rest' not in value.lower(): raise serializers.ValidationError(\"Blog post is not about Rest\") return value Object-level validation To do any other validation that requires access to multiple fields, add a method called .validate() to your Serializer subclass. This method takes a single argument, which is a dictionary of field values. It should raise a serializers.ValidationError if necessary, or just return the validated values. For example: from rest_framework import serializers class EventSerializer(serializers.Serializer): description = serializers.CharField(max_length=100) start = serializers.IntegerField() finish = serializers.IntegerField() def validate(self, data): \"\"\" Check that the start is before the stop. \"\"\" if data['start'] > data['finish']: raise serializers.ValidationError(\"finish must occur after start\") return data Validators Individual fields on a serializer can include validators, by declaring them on the field instance, for example: def multiple_of_ten(value): if value % 10 != 0: raise serializers.ValidationError('Not a multiple of ten') class GameRecord(serializers.Serializer): score = IntegerField(validators=[multiple_of_ten]) ... For more information see the validators documentation . Accessing the initial data and instance When passing an initial object or queryset to a serializer instance, the object will be made available as .instance . If no initial object is passed then the .instance attribute will be None . When passing data to a serializer instance, the unmodified data will be made available as .initial_data . If the data keyword argument is not passed then the .initial_data attribute will not exist. Dealing with nested objects The previous examples are fine for dealing with objects that only have simple datatypes, but sometimes we also need to be able to represent more complex objects, where some of the attributes of an object might not be simple datatypes such as strings, dates or integers. The Serializer class is itself a type of Field , and can be used to represent relationships where one object type is nested inside another. class UserSerializer(serializers.Serializer): email = serializers.CharField(required=True) username = serializers.CharField(max_length=100) class CommentSerializer(serializers.Serializer): user = UserSerializer() content = serializers.CharField(max_length=200) If a nested representation may optionally accept the None value you should pass the required=False flag to the nested serializer. class CommentSerializer(serializers.Serializer): user = UserSerializer(required=False) # May be an anonymous user. content = serializers.CharField(max_length=200) Similarly if a nested representation should be a list of items, you should pass the many=True flag to the nested serialized. class CommentSerializer(serializers.Serializer): user = UserSerializer(required=False) edits = UserSerializer(many=True) # A nested list of 'user' items. content = serializers.CharField(max_length=200) Writable nested representations When dealing with nested representations that support deserializing the data, any errors with nested objects will be nested under the field name of the nested object. serializer = CommentSerializer(data={'user': {'username': 'doe'}, 'content': 'baz'}) serializer.is_valid() # False serializer.errors # {'user': {'email': [u'Enter a valid e-mail address.']}} Similarly, the .validated_data property will include nested data structures. BaseSerializer BaseSerializer class that can be used to easily support alternative serialization and deserialization styles. This class implements the same basic API as the Serializer class: .data - Returns the outgoing primitive representation. There are five methods that can be overridden, depending on what functionality you want the serializer class to support: .to_representation() - Override this to support serialization, for read operations. .to_internal_value() - Override this to support deserialization, for write operations. .is_valid() - Deserializes and validates incoming data. .validated_data - Returns the validated incoming data. .errors - Returns any errors during validation. Because this class provides the same interface as the Serializer class, you can use it with the existing generic class-based views exactly as you would for a regular Serializer . Advanced serializer usage Overriding serialization and deserialization behavior If you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the .to_representation() or .to_internal_value() methods. Some reasons this might be useful include\u2026 Adding new behavior for new serializer base classes. Modifying the behavior slightly for an existing class. Improving serialization performance for a frequently accessed API endpoint that returns lots of data. The signatures for these methods are as follows: - .to_representation(self, instance) Takes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API. May be overridden in order modify the representation style. For example: def to_representation(self, instance): \"\"\"Convert `username` to lowercase.\"\"\" ret = super().to_representation(instance) ret['username'] = ret['username'].lower() return ret - .to_internal_value(self, data) Takes the unvalidated incoming data as input and should return the validated data that will be made available as serializer.validated_data . If any of the validation fails, then the method should raise a serializers.ValidationError(errors) . The errors argument should be a dictionary mapping field names (or non_field_errors ) to a list of error messages. If you don\u2019t need to alter deserialization behavior and instead want to provide object-level validation, it\u2019s recommended that you instead override the .validate() method. The data argument passed to this method will normally be the value of request.data , so the datatype it provides will depend on the parser classes you have configured for your API. Serializer Inheritance You can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example, class MyBaseSerializer(Serializer): my_field = serializers.CharField() def validate_my_field(self, value): ... class MySerializer(MyBaseSerializer): ... It\u2019s possible to declaratively remove a Field inherited from a parent class by setting the name to be None on the subclass. class MyBaseSerializer(ModelSerializer): my_field = serializers.CharField() class MySerializer(MyBaseSerializer): my_field = None Dynamically modifying fields Once a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the .fields attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer. Modifying the fields argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.","title":"Serializers"},{"location":"api-guid/serializers/#serializers","text":"Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON , XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.","title":"Serializers"},{"location":"api-guid/serializers/#declaring-serializers","text":"Let\u2019s start by creating a simple object we can use for example: from datetime import datetime class Comment(object): def __init__(self, author_name, content, created=False): self.author_name = author_name self.content = content self.created = bool(created) comment = Comment(author_name='example_name', content='foo bar') We\u2019ll declare a serializer that we can use to serialize and deserialize data that corresponds to Comment objects. from rest_framework import serializers class CommentSerializer(serializers.Serializer): author_name = serializers.CharField(required=True) content = serializers.CharField(max_length=200) created = serializers.BooleanField(required=True)","title":"Declaring Serializers"},{"location":"api-guid/serializers/#serializing-objects","text":"We can now use CommentSerializer to serialize a comment, or list of comments. serializer = CommentSerializer(comment) serializer.data # {'author_name': 'example_name', 'content': 'foo bar', 'created': False} At this point we\u2019ve translated the model instance into Python native datatypes. To finalise the serialization process we render the data into json . from rest_framework.renderers import JSONRenderer json = JSONRenderer().render(serializer.data) json # b'{\"author_name\":\"example\",\"content\":\"foo bar\",\"created\":false}'","title":"Serializing objects"},{"location":"api-guid/serializers/#deserializing-objects","text":"Deserialization is similar. First we parse a stream into Python native datatypes\u2026 import io from rest_framework.parsers import JSONParser stream = io.BytesIO(json) data = JSONParser().parse(stream) \u2026then we restore those native datatypes into a dictionary of validated data. serializer = CommentSerializer(data=data) serializer.is_valid() # True serializer.validated_data # {'content': 'foo bar', 'author_name': 'example', 'created': False)}","title":"Deserializing objects"},{"location":"api-guid/serializers/#validation","text":"When deserializing data, you always need to call is_valid() before attempting to access the validated data. If any validation errors occur, the .errors property will contain a dictionary representing the resulting error messages. For example: serializer = CommentSerializer(data={'author_name': 'foobar', 'content': 'baz'}) serializer.is_valid() # False serializer.errors # {'author_name': [u'This field is required.'], 'created': [u'This field is required.']} Each key in the dictionary will be the field name, and the values will be lists of strings of any error messages corresponding to that field. The non_field_errors key may also be present, and will list any general validation errors. When deserializing a list of items, errors will be returned as a list of dictionaries representing each of the deserialized items.","title":"Validation"},{"location":"api-guid/serializers/#raising-an-exception-on-invalid-data","text":"The .is_valid() method takes an optional raise_exception flag that will cause it to raise a serializers.ValidationError exception if there are validation errors. try: serializer.is_valid(raise_exception=True) except ValidationError: print(serializer.errors)","title":"Raising an exception on invalid data"},{"location":"api-guid/serializers/#field-level-validation","text":"You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. These methods take a single argument, which is the field value that requires validation. Your validate_<field_name> methods should return the validated value or raise a serializers.ValidationError . For example: from rest_framework import serializers class BlogPostSerializer(serializers.Serializer): title = serializers.CharField(max_length=100) content = serializers.CharField() def validate_title(self, value): \"\"\" Check that the blog post is about Django. \"\"\" if 'rest' not in value.lower(): raise serializers.ValidationError(\"Blog post is not about Rest\") return value","title":"Field-level validation"},{"location":"api-guid/serializers/#object-level-validation","text":"To do any other validation that requires access to multiple fields, add a method called .validate() to your Serializer subclass. This method takes a single argument, which is a dictionary of field values. It should raise a serializers.ValidationError if necessary, or just return the validated values. For example: from rest_framework import serializers class EventSerializer(serializers.Serializer): description = serializers.CharField(max_length=100) start = serializers.IntegerField() finish = serializers.IntegerField() def validate(self, data): \"\"\" Check that the start is before the stop. \"\"\" if data['start'] > data['finish']: raise serializers.ValidationError(\"finish must occur after start\") return data","title":"Object-level validation"},{"location":"api-guid/serializers/#validators","text":"Individual fields on a serializer can include validators, by declaring them on the field instance, for example: def multiple_of_ten(value): if value % 10 != 0: raise serializers.ValidationError('Not a multiple of ten') class GameRecord(serializers.Serializer): score = IntegerField(validators=[multiple_of_ten]) ... For more information see the validators documentation .","title":"Validators"},{"location":"api-guid/serializers/#accessing-the-initial-data-and-instance","text":"When passing an initial object or queryset to a serializer instance, the object will be made available as .instance . If no initial object is passed then the .instance attribute will be None . When passing data to a serializer instance, the unmodified data will be made available as .initial_data . If the data keyword argument is not passed then the .initial_data attribute will not exist.","title":"Accessing the initial data and instance"},{"location":"api-guid/serializers/#dealing-with-nested-objects","text":"The previous examples are fine for dealing with objects that only have simple datatypes, but sometimes we also need to be able to represent more complex objects, where some of the attributes of an object might not be simple datatypes such as strings, dates or integers. The Serializer class is itself a type of Field , and can be used to represent relationships where one object type is nested inside another. class UserSerializer(serializers.Serializer): email = serializers.CharField(required=True) username = serializers.CharField(max_length=100) class CommentSerializer(serializers.Serializer): user = UserSerializer() content = serializers.CharField(max_length=200) If a nested representation may optionally accept the None value you should pass the required=False flag to the nested serializer. class CommentSerializer(serializers.Serializer): user = UserSerializer(required=False) # May be an anonymous user. content = serializers.CharField(max_length=200) Similarly if a nested representation should be a list of items, you should pass the many=True flag to the nested serialized. class CommentSerializer(serializers.Serializer): user = UserSerializer(required=False) edits = UserSerializer(many=True) # A nested list of 'user' items. content = serializers.CharField(max_length=200)","title":"Dealing with nested objects"},{"location":"api-guid/serializers/#writable-nested-representations","text":"When dealing with nested representations that support deserializing the data, any errors with nested objects will be nested under the field name of the nested object. serializer = CommentSerializer(data={'user': {'username': 'doe'}, 'content': 'baz'}) serializer.is_valid() # False serializer.errors # {'user': {'email': [u'Enter a valid e-mail address.']}} Similarly, the .validated_data property will include nested data structures.","title":"Writable nested representations"},{"location":"api-guid/serializers/#baseserializer","text":"BaseSerializer class that can be used to easily support alternative serialization and deserialization styles. This class implements the same basic API as the Serializer class: .data - Returns the outgoing primitive representation. There are five methods that can be overridden, depending on what functionality you want the serializer class to support: .to_representation() - Override this to support serialization, for read operations. .to_internal_value() - Override this to support deserialization, for write operations. .is_valid() - Deserializes and validates incoming data. .validated_data - Returns the validated incoming data. .errors - Returns any errors during validation. Because this class provides the same interface as the Serializer class, you can use it with the existing generic class-based views exactly as you would for a regular Serializer .","title":"BaseSerializer"},{"location":"api-guid/serializers/#advanced-serializer-usage","text":"","title":"Advanced serializer usage"},{"location":"api-guid/serializers/#overriding-serialization-and-deserialization-behavior","text":"If you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the .to_representation() or .to_internal_value() methods. Some reasons this might be useful include\u2026 Adding new behavior for new serializer base classes. Modifying the behavior slightly for an existing class. Improving serialization performance for a frequently accessed API endpoint that returns lots of data. The signatures for these methods are as follows:","title":"Overriding serialization and deserialization behavior"},{"location":"api-guid/serializers/#-to_representationself-instance","text":"Takes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API. May be overridden in order modify the representation style. For example: def to_representation(self, instance): \"\"\"Convert `username` to lowercase.\"\"\" ret = super().to_representation(instance) ret['username'] = ret['username'].lower() return ret","title":"- .to_representation(self, instance)"},{"location":"api-guid/serializers/#-to_internal_valueself-data","text":"Takes the unvalidated incoming data as input and should return the validated data that will be made available as serializer.validated_data . If any of the validation fails, then the method should raise a serializers.ValidationError(errors) . The errors argument should be a dictionary mapping field names (or non_field_errors ) to a list of error messages. If you don\u2019t need to alter deserialization behavior and instead want to provide object-level validation, it\u2019s recommended that you instead override the .validate() method. The data argument passed to this method will normally be the value of request.data , so the datatype it provides will depend on the parser classes you have configured for your API.","title":"- .to_internal_value(self, data)"},{"location":"api-guid/serializers/#serializer-inheritance","text":"You can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example, class MyBaseSerializer(Serializer): my_field = serializers.CharField() def validate_my_field(self, value): ... class MySerializer(MyBaseSerializer): ... It\u2019s possible to declaratively remove a Field inherited from a parent class by setting the name to be None on the subclass. class MyBaseSerializer(ModelSerializer): my_field = serializers.CharField() class MySerializer(MyBaseSerializer): my_field = None","title":"Serializer Inheritance"},{"location":"api-guid/serializers/#dynamically-modifying-fields","text":"Once a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the .fields attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer. Modifying the fields argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.","title":"Dynamically modifying fields"},{"location":"api-guid/validators/","text":"Validators Most of the time you\u2019re dealing with validation in REST framework you\u2019ll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes. However, sometimes you\u2019ll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes. BaseValidator This is the base class for validators. You can inherit from it, or write your own. Signature : BaseValidator(message=None) message The short message should fall out on validation error. You need to define the method call . Signature __call__(self, value) value Value to validate. RequiredValidator This is a validator to check for required fields. Checks value using None. Signature : RequiredValidator(message=None) message The short message should fall out on validation error. MinLengthValidator This validator checks for greater than or equal to the minimum length of the object being iterated. Signature : MinLengthValidator(min_length, message=None) min_length Minimal length for value. message The short message should fall out on validation error. MaxLengthValidator This validator checks for less than or equal to the maximum length of the object to be iterated. Signature : MaxLengthValidator(max_length, message=None) max_length Maximum length for value. message The short message should fall out on validation error. MinValueValidator This validator checks for greater than or equal to the minimum value. Signature : MinValueValidator(min_value, message=None) min_value Minimal valid value. message The short message should fall out on validation error. MaxValueValidator This validator checks for less than or equal to the maximum value. Signature : MaxValueValidator(max_value, message=None) max_value Maximal valid value. message The short message should fall out on validation error. Writing custom validators You can write your own custom validators. Function based A validator may be any callable that raises a serializers.ValidationError on failure. def even_number(value): if value % 2 != 0: raise serializers.ValidationError('This field must be an even number.') Field-level validation You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. Class-based To write a class-based validator, use the __call__ method. Class-based validators are useful as they allow you to parameterize and reuse behavior. class MultipleOf(object): def __init__(self, base): self.base = base def __call__(self, value): if value % self.base != 0: message = 'This field must be a multiple of %d.' % self.base raise serializers.ValidationError(message)","title":"Validation"},{"location":"api-guid/validators/#validators","text":"Most of the time you\u2019re dealing with validation in REST framework you\u2019ll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes. However, sometimes you\u2019ll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes.","title":"Validators"},{"location":"api-guid/validators/#basevalidator","text":"This is the base class for validators. You can inherit from it, or write your own. Signature : BaseValidator(message=None) message The short message should fall out on validation error. You need to define the method call . Signature __call__(self, value) value Value to validate.","title":"BaseValidator"},{"location":"api-guid/validators/#requiredvalidator","text":"This is a validator to check for required fields. Checks value using None. Signature : RequiredValidator(message=None) message The short message should fall out on validation error.","title":"RequiredValidator"},{"location":"api-guid/validators/#minlengthvalidator","text":"This validator checks for greater than or equal to the minimum length of the object being iterated. Signature : MinLengthValidator(min_length, message=None) min_length Minimal length for value. message The short message should fall out on validation error.","title":"MinLengthValidator"},{"location":"api-guid/validators/#maxlengthvalidator","text":"This validator checks for less than or equal to the maximum length of the object to be iterated. Signature : MaxLengthValidator(max_length, message=None) max_length Maximum length for value. message The short message should fall out on validation error.","title":"MaxLengthValidator"},{"location":"api-guid/validators/#minvaluevalidator","text":"This validator checks for greater than or equal to the minimum value. Signature : MinValueValidator(min_value, message=None) min_value Minimal valid value. message The short message should fall out on validation error.","title":"MinValueValidator"},{"location":"api-guid/validators/#maxvaluevalidator","text":"This validator checks for less than or equal to the maximum value. Signature : MaxValueValidator(max_value, message=None) max_value Maximal valid value. message The short message should fall out on validation error.","title":"MaxValueValidator"},{"location":"api-guid/validators/#writing-custom-validators","text":"You can write your own custom validators.","title":"Writing custom validators"},{"location":"api-guid/validators/#function-based","text":"A validator may be any callable that raises a serializers.ValidationError on failure. def even_number(value): if value % 2 != 0: raise serializers.ValidationError('This field must be an even number.')","title":"Function based"},{"location":"api-guid/validators/#field-level-validation","text":"You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass.","title":"Field-level validation"},{"location":"api-guid/validators/#class-based","text":"To write a class-based validator, use the __call__ method. Class-based validators are useful as they allow you to parameterize and reuse behavior. class MultipleOf(object): def __init__(self, base): self.base = base def __call__(self, value): if value % self.base != 0: message = 'This field must be a multiple of %d.' % self.base raise serializers.ValidationError(message)","title":"Class-based"}]}
{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Rest Framework Python Rest Framework is a full-fledged rest api engine. You can concentrate all your strength on business logic, take care of the rest of the Python Rest Framework. Full documentation for the project is available at [https://nxexox.github.io/python-rest-framework/][docs]. Requirements Python (3.4, 3.5, 3.6, 3.7) six Installation Install using pip , including any optional packages you want\u2026 pip install python-rest-framework \u2026or clone the project from github. git clone git@github.com:nxexox/python-rest-framework.git Versions for Python Web Frameworks pip install python-rest-framework[flask] # For Flask framework pip install python-rest-framework[aiohttp] # For AioHttp framework pip install python-rest-framework[sanic] # For Sanic framework Example For example, we will serialize the data from the request object. First we write the serializer from rest_framework.serializers import ( Serializer, CharField, IntegerField, ListField, FloatField ) # Example serializer for parsing body data from web request. class ExampleSerializer(Serializer): char_field = CharField(label='This char field', required=True) int_field = IntegerField(label='This int field', required=True) list_float_field = ListField(child=FloatField(), required=True, min_length=2) Now we process the request body with a serializer # web request data data = { 'char_field': 'example', 'int_field': 1, 'list_float_field': [1.0, 1.1, 1.2] } ser = ExampleSerializer(data=data) if ser.is_valid(): print(ser.validated_data) else: print(ser.errors)","title":"Home"},{"location":"#python-rest-framework","text":"Python Rest Framework is a full-fledged rest api engine. You can concentrate all your strength on business logic, take care of the rest of the Python Rest Framework. Full documentation for the project is available at [https://nxexox.github.io/python-rest-framework/][docs].","title":"Python Rest Framework"},{"location":"#requirements","text":"Python (3.4, 3.5, 3.6, 3.7) six","title":"Requirements"},{"location":"#installation","text":"Install using pip , including any optional packages you want\u2026 pip install python-rest-framework \u2026or clone the project from github. git clone git@github.com:nxexox/python-rest-framework.git","title":"Installation"},{"location":"#versions-for-python-web-frameworks","text":"pip install python-rest-framework[flask] # For Flask framework pip install python-rest-framework[aiohttp] # For AioHttp framework pip install python-rest-framework[sanic] # For Sanic framework","title":"Versions for Python Web Frameworks"},{"location":"#example","text":"For example, we will serialize the data from the request object. First we write the serializer from rest_framework.serializers import ( Serializer, CharField, IntegerField, ListField, FloatField ) # Example serializer for parsing body data from web request. class ExampleSerializer(Serializer): char_field = CharField(label='This char field', required=True) int_field = IntegerField(label='This int field', required=True) list_float_field = ListField(child=FloatField(), required=True, min_length=2) Now we process the request body with a serializer # web request data data = { 'char_field': 'example', 'int_field': 1, 'list_float_field': [1.0, 1.1, 1.2] } ser = ExampleSerializer(data=data) if ser.is_valid(): print(ser.validated_data) else: print(ser.errors)","title":"Example"},{"location":"release-notes/","text":"Release Notes Versioning Minor version numbers (0.0.x) are used for changes that are API compatible. You should be able to upgrade between minor point releases without any other code changes. Medium version numbers (0.x.0) may include API changes, in line with the [deprecation policy][deprecation-policy]. You should read the release notes carefully before upgrading between medium point releases. Major version numbers (x.0.0) are reserved for substantial project milestones. 0.3.10 Date: [17th September 2019] Fixed the argument source in serializer fields into method to_representation . 0.3.9 Date: [10th September 2019] Added the argument allow_none to all Serializer Fields. 0.3.8 Date: [22th August 2019] BUG. Fix aiohttp dispatch return JsonResponse arguments. 0.3.7 Date: [15th August 2019] Change @asyncio.coroutine to async/await . 0.3.6 Date: [14th August 2019] Fix for current remove fields from base serializer. class Ser(Serializer): field_one = CharField() class TwoSer(Ser): field_one = None 0.3.5 Date: [22th Jule 2019] Fix for current work source attribute for base fields class. Fix exceptions __str__ method. Fix GenericViews MRO . Added unbound response_class from all views. Fix ValidationError arguments in views. 0.3.4 Date: [22th Jule 2019] Added source attribute for base fields class. 0.3.3 Date: [22th Jule 2019] Finish fix setup.py config. Change travis config, codecov config. 0.3.2 Date: [22th Jule 2019] Mini fix new setup.py config. Added requirements folder to data_files argument. 0.3.1 Date: [22th Jule 2019] Mini fix new setup.py config. Change requirements 0.3.0 Date: [19th Jule 2019] Added base views Added base views mixins Added views pagination Added ApiException Added views for Flask Added views for AioHttp Added views for Sanic Added utils.decorators for class check attributes and signature Fix not actual docs 0.2.2 Date: [15th Jule 2019] Added ChoiceValidator in serializers.validators . 0.2.1 Date: [22th May 2019] Mini fix processing data in Serializers _field_validation method. 0.2.0 Date: [3th April 2019] Mini fix Serializers _field_validation method. Add BooleanNullField . Remove Null values from BooleanField . 0.1.9 Date: [23th March 2019] Fix incorrect 0.1.8 VERSION 0.1.8 Date: [23th March 2019] Mini fix SerializerMethodField run to_representation method. 0.1.7 Date: [1st of January 2019] Added __deepcopy__ method on all serializer fields. 0.1.6 Date : [18th December 2018]. Fix internal logic on validation field binding. Fix settings internal validators on fields. 0.1.5 Date : [12th December 2018]. Add RegexValidator . Add Inherit Serializers . Add six.iteritems in all code. Fix mini bugs. 0.1.4 Date : [25th October 2018]. Add JsonField , DictField . Add SerializerMethodField . 0.1.3 Date : [17th October 2018]. Add DateField , TimeField , DateTimeField . Translate full project to english. child on ListField not required by default. 0.1.2 Date : [10th October 2018]. Init serializers, fields, validators, docs, tests. Push to Open Source community.","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#versioning","text":"Minor version numbers (0.0.x) are used for changes that are API compatible. You should be able to upgrade between minor point releases without any other code changes. Medium version numbers (0.x.0) may include API changes, in line with the [deprecation policy][deprecation-policy]. You should read the release notes carefully before upgrading between medium point releases. Major version numbers (x.0.0) are reserved for substantial project milestones.","title":"Versioning"},{"location":"release-notes/#0310","text":"Date: [17th September 2019] Fixed the argument source in serializer fields into method to_representation .","title":"0.3.10"},{"location":"release-notes/#039","text":"Date: [10th September 2019] Added the argument allow_none to all Serializer Fields.","title":"0.3.9"},{"location":"release-notes/#038","text":"Date: [22th August 2019] BUG. Fix aiohttp dispatch return JsonResponse arguments.","title":"0.3.8"},{"location":"release-notes/#037","text":"Date: [15th August 2019] Change @asyncio.coroutine to async/await .","title":"0.3.7"},{"location":"release-notes/#036","text":"Date: [14th August 2019] Fix for current remove fields from base serializer. class Ser(Serializer): field_one = CharField() class TwoSer(Ser): field_one = None","title":"0.3.6"},{"location":"release-notes/#035","text":"Date: [22th Jule 2019] Fix for current work source attribute for base fields class. Fix exceptions __str__ method. Fix GenericViews MRO . Added unbound response_class from all views. Fix ValidationError arguments in views.","title":"0.3.5"},{"location":"release-notes/#034","text":"Date: [22th Jule 2019] Added source attribute for base fields class.","title":"0.3.4"},{"location":"release-notes/#033","text":"Date: [22th Jule 2019] Finish fix setup.py config. Change travis config, codecov config.","title":"0.3.3"},{"location":"release-notes/#032","text":"Date: [22th Jule 2019] Mini fix new setup.py config. Added requirements folder to data_files argument.","title":"0.3.2"},{"location":"release-notes/#031","text":"Date: [22th Jule 2019] Mini fix new setup.py config. Change requirements","title":"0.3.1"},{"location":"release-notes/#030","text":"Date: [19th Jule 2019] Added base views Added base views mixins Added views pagination Added ApiException Added views for Flask Added views for AioHttp Added views for Sanic Added utils.decorators for class check attributes and signature Fix not actual docs","title":"0.3.0"},{"location":"release-notes/#022","text":"Date: [15th Jule 2019] Added ChoiceValidator in serializers.validators .","title":"0.2.2"},{"location":"release-notes/#021","text":"Date: [22th May 2019] Mini fix processing data in Serializers _field_validation method.","title":"0.2.1"},{"location":"release-notes/#020","text":"Date: [3th April 2019] Mini fix Serializers _field_validation method. Add BooleanNullField . Remove Null values from BooleanField .","title":"0.2.0"},{"location":"release-notes/#019","text":"Date: [23th March 2019] Fix incorrect 0.1.8 VERSION","title":"0.1.9"},{"location":"release-notes/#018","text":"Date: [23th March 2019] Mini fix SerializerMethodField run to_representation method.","title":"0.1.8"},{"location":"release-notes/#017","text":"Date: [1st of January 2019] Added __deepcopy__ method on all serializer fields.","title":"0.1.7"},{"location":"release-notes/#016","text":"Date : [18th December 2018]. Fix internal logic on validation field binding. Fix settings internal validators on fields.","title":"0.1.6"},{"location":"release-notes/#015","text":"Date : [12th December 2018]. Add RegexValidator . Add Inherit Serializers . Add six.iteritems in all code. Fix mini bugs.","title":"0.1.5"},{"location":"release-notes/#014","text":"Date : [25th October 2018]. Add JsonField , DictField . Add SerializerMethodField .","title":"0.1.4"},{"location":"release-notes/#013","text":"Date : [17th October 2018]. Add DateField , TimeField , DateTimeField . Translate full project to english. child on ListField not required by default.","title":"0.1.3"},{"location":"release-notes/#012","text":"Date : [10th October 2018]. Init serializers, fields, validators, docs, tests. Push to Open Source community.","title":"0.1.2"},{"location":"api-guid/fields/","text":"Fields Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects. Note: The serializer fields are declared in fields.py , but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName> . Core arguments Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted: required Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization. Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation. Defaults to True . default If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all. May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. When serializing the instance, default will be used if the the object attribute or dictionary key is not present in the instance. Note that setting a default value implies that the field is not required. Enabling the arguments of the default keyword will set the required to False . label A short text string that may be used as the name of the field in HTML form fields or other descriptive elements. validators A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should raise serializers.ValidationError . error_messages A dictionary of error codes to error messages. source The name of the field object with which the serializer field is associated. By default, the field name of the serializer = the name of the field of the object being serialized. This field changes this behavior. Example: from rest_framework import serializers class Model(object): field = 10 class StandardSerializer(serializers.Serializer): field = serializers.IntegerField() class SourceFieldSerializer(serializers.Serializer): new_field = serializers.IntegerField(source='field') print(StandardSerializer(instance=Model()).data) # {'field': 10} print(SourceFieldSerializer(instance=Model()).data) # {'new_field': 10} allow_none If set to True, skips None in the data field. Example: from rest_framework import serializers class StandardSerializer(serializers.Serializer): field = serializers.IntegerField() class AllowNoneSerializer(serializers.Serializer): field = serializers.IntegerField(allow_none=True) print(StandardSerializer(instance={'field': None}).data) # Raise Validation Exception print(AllowNoneSerializer(instance={'field': None}).data) # {'field': None} Fields BooleanField When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False , even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input. Signature: BooleanField() BooleanNullField A boolean representation that also accepts None as a valid value. When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False , even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input. Signature: BooleanNullField() CharField A text representation. Optionally validates the text to be shorter than max_length and longer than min_length . Signature: CharField(max_length=None, min_length=None, trim_whitespace=True, allow_blank=False) min_length - Validates that the input contains no fewer than this number of characters. max_length - Validates that the input contains no more than this number of characters. allow_blank - If set to True then the empty string should be considered a valid value. If set to False then the empty string is considered invalid and will raise a validation error. Defaults to False . trim_whitespace - If set to True then leading and trailing whitespace is trimmed. Defaults to True . IntegerField An integer representation. Signature : IntegerField(min_value=None, max_value=None) min_value Validate that the number provided is no less than this value. max_value Validate that the number provided is no greater than this value. FloatField A floating point representation. Signature : FloatField(min_value=None, max_value=None) min_value Validate that the number provided is no less than this value. max_value Validate that the number provided is no greater than this value. Date and time fields DateTimeField A date and time representation. Signature: DateTimeField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_DATETIME_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python datetime objects should be returned by to_representation . In this case the datetime encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_DATETIME_FORMAT setting will be used, which defaults to 'iso-8601' . DateTimeField format strings. Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29 12:34:56' ) When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class. DateField A date representation. Signature: DateField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_DATE_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python date objects should be returned by to_representation . In this case the date encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_DATE_FORMATS setting will be used, which defaults to 'iso-8601' . DateField format strings Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style dates should be used. (eg '2013-01-29' ) TimeField A time representation. Signature: TimeField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_TIME_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python time objects should be returned by to_representation . In this case the time encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_TIME_FORMATS setting will be used, which defaults to 'iso-8601' . TimeField format strings Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style times should be used. (eg '12:34:56' ) Composite fields ListField A field class that validates a list of objects. Signature : ListField(child=<A_FIELD_INSTANCE>, min_length=None, max_length=None, allow_empty=False) child - A field instance that should be used for validating the objects in the list. If this argument is not provided then objects in the list will not be validated. min_length - Validates that the list contains no fewer than this number of elements. max_length - Validates that the list contains no more than this number of elements. allow_blank - If set to True , an empty array should be considered valid. If set to False , an empty array is considered invalid and causes a validation error. The default is False . For example, to validate a list of integers you might use something like the following: scores = serializers.ListField( child=serializers.IntegerField(min_value=0, max_value=100) ) The ListField class also supports a declarative style that allows you to write reusable list field classes. class StringListField(serializers.ListField): child = serializers.CharField() We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it. JSONField A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings. Signature : JSONField() DictField A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values. Signature : DictField(child=<A_FIELD_INSTANCE>) child - A field instance that should be used for validating the values in the dictionary. If this argument is not provided then values in the mapping will not be validated. For example, to create a field that validates a mapping of strings to strings, you would write something like this: document = DictField(child=CharField()) You can also use the declarative style, as with ListField . For example: class DocumentField(DictField): child = CharField() Miscellaneous fields SerializerMethodField It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object. Signature : SerializerMethodField(method_name_get=None, method_name_pop=None) method_name_get - The name of the method on the calling serializer during object scrapping. If not included this defaults to get_<field_name> . method_name_pop - The name of the method on the calling serializer during validation data. If not included this defaults to pop_<field_name> . The serializer method referred to by the method_name_get argument should accept a single argument (in addition to self ), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example: from datetime.datetime import now from rest_framework import serializers class UserSerializer(serializers.Serializer): days_since_joined = serializers.SerializerMethodField() def get_days_since_joined(self, obj): return (now() - obj.date_joined).days The serializer method referenced by the method_name_pop argument must take one argument (in addition to self ), which is the value to process and validate. It must return whatever you want to include in the validated view of the data. For example: from datetime.datetime import now from rest_framework import serializers class UserSerializer(serializers.Serializer): rgb = serializers.SerializerMethodField() def pop_rgb(self, data): return data.split(';')[1:3] Custom fields If you want to create a custom field, you\u2019ll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date / time / datetime or None . They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using. The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype. The to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid. Examples A Basic Custom Field Let\u2019s look at an example of serializing a class that represents an RGB color value: class Color(object): \"\"\" A color represented in the RGB colorspace. \"\"\" def __init__(self, red, green, blue): assert(red >= 0 and green >= 0 and blue >= 0) assert(red < 256 and green < 256 and blue < 256) self.red, self.green, self.blue = red, green, blue class ColorField(serializers.Field): \"\"\" Color objects are serialized into 'rgb(#, #, #)' notation. \"\"\" def to_representation(self, value): return \"rgb(%d, %d, %d)\" % (value.red, value.green, value.blue) def to_internal_value(self, data): data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] return Color(red, green, blue) By default field values are treated as mapping to an attribute on the object or key Mapping collection. If you need to customize how the field value is accessed and set you need to override .get_attribute() . As an example, let\u2019s create a field that can be used to represent the class name of the object being serialized: class ClassNameField(serializers.Field): def get_attribute(self, instance): # We pass the object instance onto `to_representation`, # not just the field attribute. return instance def to_representation(self, value): \"\"\" Serialize the value's class name. \"\"\" return value.__class__.__name__ Raising validation errors Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError , like so: def to_internal_value(self, data): if not isinstance(data, six.text_type): msg = 'Incorrect type. Expected a string, but got %s' raise ValidationError(msg % type(data).__name__) if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data): raise ValidationError('Incorrect format. Expected `rgb(#,#,#)`.') data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] if any([col > 255 or col < 0 for col in (red, green, blue)]): raise ValidationError('Value out of range. Must be between 0 and 255.') return Color(red, green, blue) The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example: default_error_messages = { 'incorrect_type': 'Incorrect type. Expected a string, but got {input_type}', 'incorrect_format': 'Incorrect format. Expected `rgb(#,#,#)`.', 'out_of_range': 'Value out of range. Must be between 0 and 255.' } def to_internal_value(self, data): if not isinstance(data, six.text_type): self.fail('incorrect_type', input_type=type(data).__name__) if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data): self.fail('incorrect_format') data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] if any([col > 255 or col < 0 for col in (red, green, blue)]): self.fail('out_of_range') return Color(red, green, blue) This style keeps your error messages cleaner and more separated from your code, and should be preferred.","title":"Serializers Fields"},{"location":"api-guid/fields/#fields","text":"Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects. Note: The serializer fields are declared in fields.py , but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName> .","title":"Fields"},{"location":"api-guid/fields/#core-arguments","text":"Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:","title":"Core arguments"},{"location":"api-guid/fields/#required","text":"Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization. Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation. Defaults to True .","title":"required"},{"location":"api-guid/fields/#default","text":"If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all. May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. When serializing the instance, default will be used if the the object attribute or dictionary key is not present in the instance. Note that setting a default value implies that the field is not required. Enabling the arguments of the default keyword will set the required to False .","title":"default"},{"location":"api-guid/fields/#label","text":"A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.","title":"label"},{"location":"api-guid/fields/#validators","text":"A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should raise serializers.ValidationError .","title":"validators"},{"location":"api-guid/fields/#error_messages","text":"A dictionary of error codes to error messages.","title":"error_messages"},{"location":"api-guid/fields/#source","text":"The name of the field object with which the serializer field is associated. By default, the field name of the serializer = the name of the field of the object being serialized. This field changes this behavior. Example: from rest_framework import serializers class Model(object): field = 10 class StandardSerializer(serializers.Serializer): field = serializers.IntegerField() class SourceFieldSerializer(serializers.Serializer): new_field = serializers.IntegerField(source='field') print(StandardSerializer(instance=Model()).data) # {'field': 10} print(SourceFieldSerializer(instance=Model()).data) # {'new_field': 10}","title":"source"},{"location":"api-guid/fields/#allow_none","text":"If set to True, skips None in the data field. Example: from rest_framework import serializers class StandardSerializer(serializers.Serializer): field = serializers.IntegerField() class AllowNoneSerializer(serializers.Serializer): field = serializers.IntegerField(allow_none=True) print(StandardSerializer(instance={'field': None}).data) # Raise Validation Exception print(AllowNoneSerializer(instance={'field': None}).data) # {'field': None}","title":"allow_none"},{"location":"api-guid/fields/#fields_1","text":"","title":"Fields"},{"location":"api-guid/fields/#booleanfield","text":"When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False , even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input. Signature: BooleanField()","title":"BooleanField"},{"location":"api-guid/fields/#booleannullfield","text":"A boolean representation that also accepts None as a valid value. When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False , even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input. Signature: BooleanNullField()","title":"BooleanNullField"},{"location":"api-guid/fields/#charfield","text":"A text representation. Optionally validates the text to be shorter than max_length and longer than min_length . Signature: CharField(max_length=None, min_length=None, trim_whitespace=True, allow_blank=False) min_length - Validates that the input contains no fewer than this number of characters. max_length - Validates that the input contains no more than this number of characters. allow_blank - If set to True then the empty string should be considered a valid value. If set to False then the empty string is considered invalid and will raise a validation error. Defaults to False . trim_whitespace - If set to True then leading and trailing whitespace is trimmed. Defaults to True .","title":"CharField"},{"location":"api-guid/fields/#integerfield","text":"An integer representation. Signature : IntegerField(min_value=None, max_value=None) min_value Validate that the number provided is no less than this value. max_value Validate that the number provided is no greater than this value.","title":"IntegerField"},{"location":"api-guid/fields/#floatfield","text":"A floating point representation. Signature : FloatField(min_value=None, max_value=None) min_value Validate that the number provided is no less than this value. max_value Validate that the number provided is no greater than this value.","title":"FloatField"},{"location":"api-guid/fields/#date-and-time-fields","text":"","title":"Date and time fields"},{"location":"api-guid/fields/#datetimefield","text":"A date and time representation. Signature: DateTimeField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_DATETIME_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python datetime objects should be returned by to_representation . In this case the datetime encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_DATETIME_FORMAT setting will be used, which defaults to 'iso-8601' .","title":"DateTimeField"},{"location":"api-guid/fields/#datetimefield-format-strings","text":"Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29 12:34:56' ) When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.","title":"DateTimeField format strings."},{"location":"api-guid/fields/#datefield","text":"A date representation. Signature: DateField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_DATE_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python date objects should be returned by to_representation . In this case the date encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_DATE_FORMATS setting will be used, which defaults to 'iso-8601' .","title":"DateField"},{"location":"api-guid/fields/#datefield-format-strings","text":"Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style dates should be used. (eg '2013-01-29' )","title":"DateField format strings"},{"location":"api-guid/fields/#timefield","text":"A time representation. Signature: TimeField(format=None, input_format=None) format - A string representing the output format. If not specified, this defaults to the same value as the DEFAULT_TIME_FORMAT settings key, which will be 'iso-8601' unless set. Setting to a format string indicates that to_representation return values should be coerced to string output. Format strings are described below. Setting this value to None indicates that Python time objects should be returned by to_representation . In this case the time encoding will be determined by the renderer. input_format - String representing the input format which may be used to parse the date. If not specified, the DEFAULT_INPUT_TIME_FORMATS setting will be used, which defaults to 'iso-8601' .","title":"TimeField"},{"location":"api-guid/fields/#timefield-format-strings","text":"Format strings may either be [Python strftime formats][strftime] which explicitly specify the format, or the special string 'iso-8601' , which indicates that ISO 8601 style times should be used. (eg '12:34:56' )","title":"TimeField format strings"},{"location":"api-guid/fields/#composite-fields","text":"","title":"Composite fields"},{"location":"api-guid/fields/#listfield","text":"A field class that validates a list of objects. Signature : ListField(child=<A_FIELD_INSTANCE>, min_length=None, max_length=None, allow_empty=False) child - A field instance that should be used for validating the objects in the list. If this argument is not provided then objects in the list will not be validated. min_length - Validates that the list contains no fewer than this number of elements. max_length - Validates that the list contains no more than this number of elements. allow_blank - If set to True , an empty array should be considered valid. If set to False , an empty array is considered invalid and causes a validation error. The default is False . For example, to validate a list of integers you might use something like the following: scores = serializers.ListField( child=serializers.IntegerField(min_value=0, max_value=100) ) The ListField class also supports a declarative style that allows you to write reusable list field classes. class StringListField(serializers.ListField): child = serializers.CharField() We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.","title":"ListField"},{"location":"api-guid/fields/#jsonfield","text":"A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings. Signature : JSONField()","title":"JSONField"},{"location":"api-guid/fields/#dictfield","text":"A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values. Signature : DictField(child=<A_FIELD_INSTANCE>) child - A field instance that should be used for validating the values in the dictionary. If this argument is not provided then values in the mapping will not be validated. For example, to create a field that validates a mapping of strings to strings, you would write something like this: document = DictField(child=CharField()) You can also use the declarative style, as with ListField . For example: class DocumentField(DictField): child = CharField()","title":"DictField"},{"location":"api-guid/fields/#miscellaneous-fields","text":"","title":"Miscellaneous fields"},{"location":"api-guid/fields/#serializermethodfield","text":"It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object. Signature : SerializerMethodField(method_name_get=None, method_name_pop=None) method_name_get - The name of the method on the calling serializer during object scrapping. If not included this defaults to get_<field_name> . method_name_pop - The name of the method on the calling serializer during validation data. If not included this defaults to pop_<field_name> . The serializer method referred to by the method_name_get argument should accept a single argument (in addition to self ), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example: from datetime.datetime import now from rest_framework import serializers class UserSerializer(serializers.Serializer): days_since_joined = serializers.SerializerMethodField() def get_days_since_joined(self, obj): return (now() - obj.date_joined).days The serializer method referenced by the method_name_pop argument must take one argument (in addition to self ), which is the value to process and validate. It must return whatever you want to include in the validated view of the data. For example: from datetime.datetime import now from rest_framework import serializers class UserSerializer(serializers.Serializer): rgb = serializers.SerializerMethodField() def pop_rgb(self, data): return data.split(';')[1:3]","title":"SerializerMethodField"},{"location":"api-guid/fields/#custom-fields","text":"If you want to create a custom field, you\u2019ll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date / time / datetime or None . They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using. The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype. The to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.","title":"Custom fields"},{"location":"api-guid/fields/#examples","text":"","title":"Examples"},{"location":"api-guid/fields/#a-basic-custom-field","text":"Let\u2019s look at an example of serializing a class that represents an RGB color value: class Color(object): \"\"\" A color represented in the RGB colorspace. \"\"\" def __init__(self, red, green, blue): assert(red >= 0 and green >= 0 and blue >= 0) assert(red < 256 and green < 256 and blue < 256) self.red, self.green, self.blue = red, green, blue class ColorField(serializers.Field): \"\"\" Color objects are serialized into 'rgb(#, #, #)' notation. \"\"\" def to_representation(self, value): return \"rgb(%d, %d, %d)\" % (value.red, value.green, value.blue) def to_internal_value(self, data): data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] return Color(red, green, blue) By default field values are treated as mapping to an attribute on the object or key Mapping collection. If you need to customize how the field value is accessed and set you need to override .get_attribute() . As an example, let\u2019s create a field that can be used to represent the class name of the object being serialized: class ClassNameField(serializers.Field): def get_attribute(self, instance): # We pass the object instance onto `to_representation`, # not just the field attribute. return instance def to_representation(self, value): \"\"\" Serialize the value's class name. \"\"\" return value.__class__.__name__","title":"A Basic Custom Field"},{"location":"api-guid/fields/#raising-validation-errors","text":"Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError , like so: def to_internal_value(self, data): if not isinstance(data, six.text_type): msg = 'Incorrect type. Expected a string, but got %s' raise ValidationError(msg % type(data).__name__) if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data): raise ValidationError('Incorrect format. Expected `rgb(#,#,#)`.') data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] if any([col > 255 or col < 0 for col in (red, green, blue)]): raise ValidationError('Value out of range. Must be between 0 and 255.') return Color(red, green, blue) The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example: default_error_messages = { 'incorrect_type': 'Incorrect type. Expected a string, but got {input_type}', 'incorrect_format': 'Incorrect format. Expected `rgb(#,#,#)`.', 'out_of_range': 'Value out of range. Must be between 0 and 255.' } def to_internal_value(self, data): if not isinstance(data, six.text_type): self.fail('incorrect_type', input_type=type(data).__name__) if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data): self.fail('incorrect_format') data = data.strip('rgb(').rstrip(')') red, green, blue = [int(col) for col in data.split(',')] if any([col > 255 or col < 0 for col in (red, green, blue)]): self.fail('out_of_range') return Color(red, green, blue) This style keeps your error messages cleaner and more separated from your code, and should be preferred.","title":"Raising validation errors"},{"location":"api-guid/serializers/","text":"Serializers Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON , XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data. Declaring Serializers Let\u2019s start by creating a simple object we can use for example: from datetime import datetime class Comment(object): def __init__(self, author_name, content, created=False): self.author_name = author_name self.content = content self.created = bool(created) comment = Comment(author_name='example_name', content='foo bar') We\u2019ll declare a serializer that we can use to serialize and deserialize data that corresponds to Comment objects. from rest_framework import serializers class CommentSerializer(serializers.Serializer): author_name = serializers.CharField(required=True) content = serializers.CharField(max_length=200) created = serializers.BooleanField(required=True) Serializing objects We can now use CommentSerializer to serialize a comment, or list of comments. serializer = CommentSerializer(comment) serializer.data # {'author_name': 'example_name', 'content': 'foo bar', 'created': False} Deserializing objects We restore those native datatypes into a dictionary of validated data. serializer = CommentSerializer(data=data) serializer.is_valid() # True serializer.validated_data # {'content': 'foo bar', 'author_name': 'example', 'created': False)} With the same ease, you can deserialize several objects. You just need to add the many=True flag to the serializer constructor. serializer = CommentSerializer(data=[data, data], many=True) serializer.is_valid() # True serializer.validated_data # [ # {'content': 'foo bar', 'author_name': 'example', 'created': False)}, # {'content': 'foo bar', 'author_name': 'example', 'created': False)} # ] Validation When deserializing data, you always need to call is_valid() before attempting to access the validated data. If any validation errors occur, the .errors property will contain a dictionary representing the resulting error messages. For example: serializer = CommentSerializer(data={'author_name': 'foobar', 'content': 'baz'}) serializer.is_valid() # False serializer.errors # {'created': ['This field is required.']} Each key in the dictionary will be the field name, and the values will be lists of strings of any error messages corresponding to that field. The non_field_errors key may also be present, and will list any general validation errors. When deserializing a list of items, errors will be returned as a list of dictionaries representing each of the deserialized items. Raising an exception on invalid data The .is_valid() method takes an optional raise_exception flag that will cause it to raise a serializers.ValidationError exception if there are validation errors. serializer = CommentSerializer(data={'author_name': 'foobar', 'content': 'baz'}) try: serializer.is_valid(raise_exception=True) except ValidationError: print(serializer.errors) # {'created': ['This field is required.']} Field-level validation You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. These methods take a single argument, which is the field value that requires validation. Your validate_<field_name> methods should return the validated value or raise a serializers.ValidationError . For example: from rest_framework import serializers class BlogPostSerializer(serializers.Serializer): title = serializers.CharField(max_length=100) content = serializers.CharField() def validate_title(self, value): \"\"\" Check that the blog post is about Django. \"\"\" if 'rest' not in value.lower(): raise serializers.ValidationError(\"Blog post is not about Rest\") return value Object-level validation To do any other validation that requires access to multiple fields, add a method called .validate() to your Serializer subclass. This method takes a single argument, which is a dictionary of field values. It should raise a serializers.ValidationError if necessary, or just return the validated values. For example: from rest_framework import serializers class EventSerializer(serializers.Serializer): description = serializers.CharField(max_length=100) start = serializers.IntegerField() finish = serializers.IntegerField() def validate(self, data): \"\"\" Check that the start is before the stop. \"\"\" if data['start'] > data['finish']: raise serializers.ValidationError(\"finish must occur after start\") return data Validators Individual fields on a serializer can include validators, by declaring them on the field instance, for example: def multiple_of_ten(value): if value % 10 != 0: raise serializers.ValidationError('Not a multiple of ten') class GameRecord(serializers.Serializer): score = IntegerField(validators=[multiple_of_ten]) # ... For more information see the validators documentation . Accessing the initial data and instance When passing an initial object or queryset to a serializer instance, the object will be made available as .instance . If no initial object is passed then the .instance attribute will be None . When passing data to a serializer instance, the unmodified data will be made available as .initial_data . If the data keyword argument is not passed then the .initial_data attribute will not exist. Dealing with nested objects The previous examples are fine for dealing with objects that only have simple datatypes, but sometimes we also need to be able to represent more complex objects, where some of the attributes of an object might not be simple datatypes such as strings, dates or integers. The Serializer class is itself a type of Field , and can be used to represent relationships where one object type is nested inside another. class UserSerializer(serializers.Serializer): email = serializers.CharField(required=True) username = serializers.CharField(max_length=100) class CommentSerializer(serializers.Serializer): user = UserSerializer() content = serializers.CharField(max_length=200) If a nested representation may optionally accept the None value you should pass the required=False flag to the nested serializer. class CommentSerializer(serializers.Serializer): user = UserSerializer(required=False) # May be an anonymous user. content = serializers.CharField(max_length=200) Similarly if a nested representation should be a list of items, you should pass the many=True flag to the nested serialized. class CommentSerializer(serializers.Serializer): user = UserSerializer(required=False) edits = UserSerializer(many=True) # A nested list of 'user' items. content = serializers.CharField(max_length=200) Writable nested representations When dealing with nested representations that support deserializing the data, any errors with nested objects will be nested under the field name of the nested object. serializer = CommentSerializer(data={'user': {'username': 'doe'}, 'content': 'baz'}) serializer.is_valid() # False serializer.errors # {'user': {'email': [u'Enter a valid e-mail address.']}} Similarly, the .validated_data property will include nested data structures. BaseSerializer BaseSerializer class that can be used to easily support alternative serialization and deserialization styles. This class implements the same basic API as the Serializer class: .data - Returns the outgoing primitive representation. There are five methods that can be overridden, depending on what functionality you want the serializer class to support: .to_representation() - Override this to support serialization, for read operations. .to_internal_value() - Override this to support deserialization, for write operations. .is_valid() - Deserializes and validates incoming data. .validated_data - Returns the validated incoming data. .errors - Returns any errors during validation. Because this class provides the same interface as the Serializer class, you can use it with the existing generic class-based views exactly as you would for a regular Serializer . Advanced serializer usage Overriding serialization and deserialization behavior If you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the .to_representation() or .to_internal_value() methods. Some reasons this might be useful include\u2026 Adding new behavior for new serializer base classes. Modifying the behavior slightly for an existing class. Improving serialization performance for a frequently accessed API endpoint that returns lots of data. The signatures for these methods are as follows: .to_representation(self, instance) Takes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API. May be overridden in order modify the representation style. For example: def to_representation(self, instance): \"\"\"Convert `username` to lowercase.\"\"\" ret = super().to_representation(instance) ret['username'] = ret['username'].lower() return ret .to_internal_value(self, data) Takes the unvalidated incoming data as input and should return the validated data that will be made available as serializer.validated_data . If any of the validation fails, then the method should raise a serializers.ValidationError(errors) . The errors argument should be a dictionary mapping field names (or non_field_errors ) to a list of error messages. If you don\u2019t need to alter deserialization behavior and instead want to provide object-level validation, it\u2019s recommended that you instead override the .validate() method. The data argument passed to this method will normally be the value of request.data , so the datatype it provides will depend on the parser classes you have configured for your API. Serializer Inheritance You can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example, class MyBaseSerializer(Serializer): my_field = serializers.CharField() def validate_my_field(self, value): ... class MySerializer(MyBaseSerializer): ... It\u2019s possible to declaratively remove a Field inherited from a parent class by setting the name to be None on the subclass. class MyBaseSerializer(ModelSerializer): my_field = serializers.CharField() class MySerializer(MyBaseSerializer): my_field = None Dynamically modifying fields Once a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the .fields attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer. Modifying the fields argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.","title":"Serializers"},{"location":"api-guid/serializers/#serializers","text":"Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON , XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.","title":"Serializers"},{"location":"api-guid/serializers/#declaring-serializers","text":"Let\u2019s start by creating a simple object we can use for example: from datetime import datetime class Comment(object): def __init__(self, author_name, content, created=False): self.author_name = author_name self.content = content self.created = bool(created) comment = Comment(author_name='example_name', content='foo bar') We\u2019ll declare a serializer that we can use to serialize and deserialize data that corresponds to Comment objects. from rest_framework import serializers class CommentSerializer(serializers.Serializer): author_name = serializers.CharField(required=True) content = serializers.CharField(max_length=200) created = serializers.BooleanField(required=True)","title":"Declaring Serializers"},{"location":"api-guid/serializers/#serializing-objects","text":"We can now use CommentSerializer to serialize a comment, or list of comments. serializer = CommentSerializer(comment) serializer.data # {'author_name': 'example_name', 'content': 'foo bar', 'created': False}","title":"Serializing objects"},{"location":"api-guid/serializers/#deserializing-objects","text":"We restore those native datatypes into a dictionary of validated data. serializer = CommentSerializer(data=data) serializer.is_valid() # True serializer.validated_data # {'content': 'foo bar', 'author_name': 'example', 'created': False)} With the same ease, you can deserialize several objects. You just need to add the many=True flag to the serializer constructor. serializer = CommentSerializer(data=[data, data], many=True) serializer.is_valid() # True serializer.validated_data # [ # {'content': 'foo bar', 'author_name': 'example', 'created': False)}, # {'content': 'foo bar', 'author_name': 'example', 'created': False)} # ]","title":"Deserializing objects"},{"location":"api-guid/serializers/#validation","text":"When deserializing data, you always need to call is_valid() before attempting to access the validated data. If any validation errors occur, the .errors property will contain a dictionary representing the resulting error messages. For example: serializer = CommentSerializer(data={'author_name': 'foobar', 'content': 'baz'}) serializer.is_valid() # False serializer.errors # {'created': ['This field is required.']} Each key in the dictionary will be the field name, and the values will be lists of strings of any error messages corresponding to that field. The non_field_errors key may also be present, and will list any general validation errors. When deserializing a list of items, errors will be returned as a list of dictionaries representing each of the deserialized items.","title":"Validation"},{"location":"api-guid/serializers/#raising-an-exception-on-invalid-data","text":"The .is_valid() method takes an optional raise_exception flag that will cause it to raise a serializers.ValidationError exception if there are validation errors. serializer = CommentSerializer(data={'author_name': 'foobar', 'content': 'baz'}) try: serializer.is_valid(raise_exception=True) except ValidationError: print(serializer.errors) # {'created': ['This field is required.']}","title":"Raising an exception on invalid data"},{"location":"api-guid/serializers/#field-level-validation","text":"You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. These methods take a single argument, which is the field value that requires validation. Your validate_<field_name> methods should return the validated value or raise a serializers.ValidationError . For example: from rest_framework import serializers class BlogPostSerializer(serializers.Serializer): title = serializers.CharField(max_length=100) content = serializers.CharField() def validate_title(self, value): \"\"\" Check that the blog post is about Django. \"\"\" if 'rest' not in value.lower(): raise serializers.ValidationError(\"Blog post is not about Rest\") return value","title":"Field-level validation"},{"location":"api-guid/serializers/#object-level-validation","text":"To do any other validation that requires access to multiple fields, add a method called .validate() to your Serializer subclass. This method takes a single argument, which is a dictionary of field values. It should raise a serializers.ValidationError if necessary, or just return the validated values. For example: from rest_framework import serializers class EventSerializer(serializers.Serializer): description = serializers.CharField(max_length=100) start = serializers.IntegerField() finish = serializers.IntegerField() def validate(self, data): \"\"\" Check that the start is before the stop. \"\"\" if data['start'] > data['finish']: raise serializers.ValidationError(\"finish must occur after start\") return data","title":"Object-level validation"},{"location":"api-guid/serializers/#validators","text":"Individual fields on a serializer can include validators, by declaring them on the field instance, for example: def multiple_of_ten(value): if value % 10 != 0: raise serializers.ValidationError('Not a multiple of ten') class GameRecord(serializers.Serializer): score = IntegerField(validators=[multiple_of_ten]) # ... For more information see the validators documentation .","title":"Validators"},{"location":"api-guid/serializers/#accessing-the-initial-data-and-instance","text":"When passing an initial object or queryset to a serializer instance, the object will be made available as .instance . If no initial object is passed then the .instance attribute will be None . When passing data to a serializer instance, the unmodified data will be made available as .initial_data . If the data keyword argument is not passed then the .initial_data attribute will not exist.","title":"Accessing the initial data and instance"},{"location":"api-guid/serializers/#dealing-with-nested-objects","text":"The previous examples are fine for dealing with objects that only have simple datatypes, but sometimes we also need to be able to represent more complex objects, where some of the attributes of an object might not be simple datatypes such as strings, dates or integers. The Serializer class is itself a type of Field , and can be used to represent relationships where one object type is nested inside another. class UserSerializer(serializers.Serializer): email = serializers.CharField(required=True) username = serializers.CharField(max_length=100) class CommentSerializer(serializers.Serializer): user = UserSerializer() content = serializers.CharField(max_length=200) If a nested representation may optionally accept the None value you should pass the required=False flag to the nested serializer. class CommentSerializer(serializers.Serializer): user = UserSerializer(required=False) # May be an anonymous user. content = serializers.CharField(max_length=200) Similarly if a nested representation should be a list of items, you should pass the many=True flag to the nested serialized. class CommentSerializer(serializers.Serializer): user = UserSerializer(required=False) edits = UserSerializer(many=True) # A nested list of 'user' items. content = serializers.CharField(max_length=200)","title":"Dealing with nested objects"},{"location":"api-guid/serializers/#writable-nested-representations","text":"When dealing with nested representations that support deserializing the data, any errors with nested objects will be nested under the field name of the nested object. serializer = CommentSerializer(data={'user': {'username': 'doe'}, 'content': 'baz'}) serializer.is_valid() # False serializer.errors # {'user': {'email': [u'Enter a valid e-mail address.']}} Similarly, the .validated_data property will include nested data structures.","title":"Writable nested representations"},{"location":"api-guid/serializers/#baseserializer","text":"BaseSerializer class that can be used to easily support alternative serialization and deserialization styles. This class implements the same basic API as the Serializer class: .data - Returns the outgoing primitive representation. There are five methods that can be overridden, depending on what functionality you want the serializer class to support: .to_representation() - Override this to support serialization, for read operations. .to_internal_value() - Override this to support deserialization, for write operations. .is_valid() - Deserializes and validates incoming data. .validated_data - Returns the validated incoming data. .errors - Returns any errors during validation. Because this class provides the same interface as the Serializer class, you can use it with the existing generic class-based views exactly as you would for a regular Serializer .","title":"BaseSerializer"},{"location":"api-guid/serializers/#advanced-serializer-usage","text":"","title":"Advanced serializer usage"},{"location":"api-guid/serializers/#overriding-serialization-and-deserialization-behavior","text":"If you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the .to_representation() or .to_internal_value() methods. Some reasons this might be useful include\u2026 Adding new behavior for new serializer base classes. Modifying the behavior slightly for an existing class. Improving serialization performance for a frequently accessed API endpoint that returns lots of data. The signatures for these methods are as follows:","title":"Overriding serialization and deserialization behavior"},{"location":"api-guid/serializers/#to_representationself-instance","text":"Takes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API. May be overridden in order modify the representation style. For example: def to_representation(self, instance): \"\"\"Convert `username` to lowercase.\"\"\" ret = super().to_representation(instance) ret['username'] = ret['username'].lower() return ret","title":".to_representation(self, instance)"},{"location":"api-guid/serializers/#to_internal_valueself-data","text":"Takes the unvalidated incoming data as input and should return the validated data that will be made available as serializer.validated_data . If any of the validation fails, then the method should raise a serializers.ValidationError(errors) . The errors argument should be a dictionary mapping field names (or non_field_errors ) to a list of error messages. If you don\u2019t need to alter deserialization behavior and instead want to provide object-level validation, it\u2019s recommended that you instead override the .validate() method. The data argument passed to this method will normally be the value of request.data , so the datatype it provides will depend on the parser classes you have configured for your API.","title":".to_internal_value(self, data)"},{"location":"api-guid/serializers/#serializer-inheritance","text":"You can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example, class MyBaseSerializer(Serializer): my_field = serializers.CharField() def validate_my_field(self, value): ... class MySerializer(MyBaseSerializer): ... It\u2019s possible to declaratively remove a Field inherited from a parent class by setting the name to be None on the subclass. class MyBaseSerializer(ModelSerializer): my_field = serializers.CharField() class MySerializer(MyBaseSerializer): my_field = None","title":"Serializer Inheritance"},{"location":"api-guid/serializers/#dynamically-modifying-fields","text":"Once a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the .fields attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer. Modifying the fields argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.","title":"Dynamically modifying fields"},{"location":"api-guid/validators/","text":"Validators Most of the time you\u2019re dealing with validation in REST framework you\u2019ll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes. However, sometimes you\u2019ll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes. BaseValidator This is the base class for validators. You can inherit from it, or write your own. Signature : BaseValidator(message=None) message The short message should fall out on validation error. You need to define the method call . Signature __call__(self, value) value Value to validate. RequiredValidator This is a validator to check for required fields. Checks value using None. Signature : RequiredValidator(message=None) message The short message should fall out on validation error. Example : validator = RequiredValidator() validator('Not empty string') try: validator(None) except ValidationError: pass MinLengthValidator This validator checks for greater than or equal to the minimum length of the object being iterated. Signature : MinLengthValidator(min_length, message=None) min_length Minimal length for value. message The short message should fall out on validation error. Example : validator = MinLengthValidator(10) validator(list(range(15)) try: validator(list(range(9))) except ValidationError: pass MaxLengthValidator This validator checks for less than or equal to the maximum length of the object to be iterated. Signature : MaxLengthValidator(max_length, message=None) max_length Maximum length for value. message The short message should fall out on validation error. Example : validator = MaxLengthValidator(10) validator(list(range(9)) try: validator(list(range(15))) except ValidationError: pass MinValueValidator This validator checks for greater than or equal to the minimum value. Signature : MinValueValidator(min_value, message=None) min_value Minimal valid value. message The short message should fall out on validation error. Example : validator = MinValueValidator(10) validator(15) try: validator(9) except ValidationError: pass MaxValueValidator This validator checks for less than or equal to the maximum value. Signature : MaxValueValidator(max_value, message=None) max_value Maximal valid value. message The short message should fall out on validation error. Example : validator = MaxValueValidator(10) validator(9) try: validator(15) except ValidationError: pass RegexValidator This validator checks the string against a regular expression. Signature : RegexValidator(regex, inverse_match=None, flags=None, message=None) regex Regex raw inverse_match - A flag indicating whether to invert the response? Default: False . flags - Flags for compiling regular expression. Default 0 . message The short message should fall out on validation error. Example : validator = RegexValidator(r'\\d+') validator('123') try: validator('example') except ValidationError: pass validator = RegexValidator(r'\\d+', True) validator('test') ChoiceValidator This validator checks a value for an entry in a predefined list of values. Signature : ChoiceValidator(choices, message=None) choices Valid values. Iter object. If list , tuple , set check into iter object. If dict , check key. message The short message should fall out on validation error. Example : validator = ChoiceValidator([1, 2, 3]) validator(2) try: validator(15) except ValidationError: pass Writing custom validators You can write your own custom validators. Function based A validator may be any callable that raises a serializers.ValidationError on failure. def even_number(value): if value % 2 != 0: raise serializers.ValidationError('This field must be an even number.') Field-level validation You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. Read more Field Level Validation Class-based To write a class-based validator, use the __call__ method. Class-based validators are useful as they allow you to parameterize and reuse behavior. class MultipleOf(object): def __init__(self, base): self.base = base def __call__(self, value): if value % self.base != 0: message = 'This field must be a multiple of %d.' % self.base raise serializers.ValidationError(message)","title":"Serializers Validation"},{"location":"api-guid/validators/#validators","text":"Most of the time you\u2019re dealing with validation in REST framework you\u2019ll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes. However, sometimes you\u2019ll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes.","title":"Validators"},{"location":"api-guid/validators/#basevalidator","text":"This is the base class for validators. You can inherit from it, or write your own. Signature : BaseValidator(message=None) message The short message should fall out on validation error. You need to define the method call . Signature __call__(self, value) value Value to validate.","title":"BaseValidator"},{"location":"api-guid/validators/#requiredvalidator","text":"This is a validator to check for required fields. Checks value using None. Signature : RequiredValidator(message=None) message The short message should fall out on validation error. Example : validator = RequiredValidator() validator('Not empty string') try: validator(None) except ValidationError: pass","title":"RequiredValidator"},{"location":"api-guid/validators/#minlengthvalidator","text":"This validator checks for greater than or equal to the minimum length of the object being iterated. Signature : MinLengthValidator(min_length, message=None) min_length Minimal length for value. message The short message should fall out on validation error. Example : validator = MinLengthValidator(10) validator(list(range(15)) try: validator(list(range(9))) except ValidationError: pass","title":"MinLengthValidator"},{"location":"api-guid/validators/#maxlengthvalidator","text":"This validator checks for less than or equal to the maximum length of the object to be iterated. Signature : MaxLengthValidator(max_length, message=None) max_length Maximum length for value. message The short message should fall out on validation error. Example : validator = MaxLengthValidator(10) validator(list(range(9)) try: validator(list(range(15))) except ValidationError: pass","title":"MaxLengthValidator"},{"location":"api-guid/validators/#minvaluevalidator","text":"This validator checks for greater than or equal to the minimum value. Signature : MinValueValidator(min_value, message=None) min_value Minimal valid value. message The short message should fall out on validation error. Example : validator = MinValueValidator(10) validator(15) try: validator(9) except ValidationError: pass","title":"MinValueValidator"},{"location":"api-guid/validators/#maxvaluevalidator","text":"This validator checks for less than or equal to the maximum value. Signature : MaxValueValidator(max_value, message=None) max_value Maximal valid value. message The short message should fall out on validation error. Example : validator = MaxValueValidator(10) validator(9) try: validator(15) except ValidationError: pass","title":"MaxValueValidator"},{"location":"api-guid/validators/#regexvalidator","text":"This validator checks the string against a regular expression. Signature : RegexValidator(regex, inverse_match=None, flags=None, message=None) regex Regex raw inverse_match - A flag indicating whether to invert the response? Default: False . flags - Flags for compiling regular expression. Default 0 . message The short message should fall out on validation error. Example : validator = RegexValidator(r'\\d+') validator('123') try: validator('example') except ValidationError: pass validator = RegexValidator(r'\\d+', True) validator('test')","title":"RegexValidator"},{"location":"api-guid/validators/#choicevalidator","text":"This validator checks a value for an entry in a predefined list of values. Signature : ChoiceValidator(choices, message=None) choices Valid values. Iter object. If list , tuple , set check into iter object. If dict , check key. message The short message should fall out on validation error. Example : validator = ChoiceValidator([1, 2, 3]) validator(2) try: validator(15) except ValidationError: pass","title":"ChoiceValidator"},{"location":"api-guid/validators/#writing-custom-validators","text":"You can write your own custom validators.","title":"Writing custom validators"},{"location":"api-guid/validators/#function-based","text":"A validator may be any callable that raises a serializers.ValidationError on failure. def even_number(value): if value % 2 != 0: raise serializers.ValidationError('This field must be an even number.')","title":"Function based"},{"location":"api-guid/validators/#field-level-validation","text":"You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. Read more Field Level Validation","title":"Field-level validation"},{"location":"api-guid/validators/#class-based","text":"To write a class-based validator, use the __call__ method. Class-based validators are useful as they allow you to parameterize and reuse behavior. class MultipleOf(object): def __init__(self, base): self.base = base def __call__(self, value): if value % self.base != 0: message = 'This field must be a multiple of %d.' % self.base raise serializers.ValidationError(message)","title":"Class-based"},{"location":"api-guid/views/aiohttp/","text":"Flask Views AioHTTP has one BaseClassViews - View . Python-Rest-Framework is connected to both. Note: To use AioHttpViews you need to install aiohttp . All Classes can be found here: from rest_framework.views.aiohttp import * AioHttpBaseViews AioHTTPApiView This class is a successor: aiohttp.web.View , rest_framework.views.BaseApiView . What the class consists of: The class is completely safe. The class does not completely change the source code of Flask, and does not restrict from the source functions of the framework. Class implemented properties: request_object , current_request_method . Using the rest_framework.views.BaseApiView._dispatch method is configured and can be adjusted by setting the use_dispatch . By default use_dispatch set in True . The class itself uses response_class=json_response : from aiohttp.web import json_response Example: from rest_framework.views.aiohttp import AioHTTPApiView class MyView(AioHTTPApiView): async def get(self): # your view code AioHttp Mixins Mixins for AioHttp \u200b\u200bare the same useful mixins as rest_framework.views.mixins , but they can only be used in AioHttp . GetValidJsonMixin The class is successor: rest_framework.views.GetSerializerMixin Mixin adds the .get_valid_json() method, which parses the query and body of the query, merges them, and automatically serializes it and validates it with rest_framework.serializers.Serializer . You can describe the serializers themselves in the serializers_classes class attribute. .get_valid_json() This method retrieves from the request all the data that the user sent. Serializes and validates them and returns as a dictionary. Signature: .get_valid_json(parse_query=False, raise_exception=True) -> dict parse_query(bool) - Parse query params? raise_exception(bool) - Raise exception ValidationError , if validation error. Example: from rest_framework.views.aiohttp import AioHTTPApiView, GetValidJsonMixin class MyView(AioHTTPApiView, GetValidJsonMixin): serializer_classes = { 'get': MySerializer() } async def get(self): request_data = await self.get_valid_json() ############# ### Equivalent to ############# from rest_framework.views.aiohttp import AioHTTPApiView from rest_framework.views.mixins import GetSerializerMixin class MyView(AioHTTPApiView, GetSerializerMixin): async def get(self): serializer_class = self.get_request_serializer() try: data = await self.request_object.json() except Exception: data = {} ser = serializer_class(data=data) ser.is_valid(raise_exception=True) request_data = ser.validated_data AioHttpGenericViews GenericViews are ready-to-use classes, compiled from base classes and mixins for various needs. GetSerializerApiGenericView Generic Api view for GetSerializer methods. Parents: rest_framework.views.aiohttp.AioHTTPApiView rest_framework.views.mixins.GetSerializer GetResponseApiGenericView Generic Api view for GetResponse methods. Parents: rest_framework.views.aiohttp.AioHTTPApiView rest_framework.views.mixins.GetResponse GetValidJsonApiGenericView Generic Api view for GetValidJson methods. Parents: rest_framework.views.aiohttp.AioHTTPApiView rest_framework.views.aiohttp.mixins.GetValidJson ApiGenericView Generic Api view for all mixins methods. Parents: rest_framework.views.aiohttp.AioHTTPApiView rest_framework.views.aiohttp.mixins.GetValidJson rest_framework.views.mixins.GetSerializer rest_framework.views.mixins.GetResponse","title":"AioHTTPViews"},{"location":"api-guid/views/aiohttp/#flask-views","text":"AioHTTP has one BaseClassViews - View . Python-Rest-Framework is connected to both. Note: To use AioHttpViews you need to install aiohttp . All Classes can be found here: from rest_framework.views.aiohttp import *","title":"Flask Views"},{"location":"api-guid/views/aiohttp/#aiohttpbaseviews","text":"","title":"AioHttpBaseViews"},{"location":"api-guid/views/aiohttp/#aiohttpapiview","text":"This class is a successor: aiohttp.web.View , rest_framework.views.BaseApiView . What the class consists of: The class is completely safe. The class does not completely change the source code of Flask, and does not restrict from the source functions of the framework. Class implemented properties: request_object , current_request_method . Using the rest_framework.views.BaseApiView._dispatch method is configured and can be adjusted by setting the use_dispatch . By default use_dispatch set in True . The class itself uses response_class=json_response : from aiohttp.web import json_response Example: from rest_framework.views.aiohttp import AioHTTPApiView class MyView(AioHTTPApiView): async def get(self): # your view code","title":"AioHTTPApiView"},{"location":"api-guid/views/aiohttp/#aiohttp-mixins","text":"Mixins for AioHttp \u200b\u200bare the same useful mixins as rest_framework.views.mixins , but they can only be used in AioHttp .","title":"AioHttp Mixins"},{"location":"api-guid/views/aiohttp/#getvalidjsonmixin","text":"The class is successor: rest_framework.views.GetSerializerMixin Mixin adds the .get_valid_json() method, which parses the query and body of the query, merges them, and automatically serializes it and validates it with rest_framework.serializers.Serializer . You can describe the serializers themselves in the serializers_classes class attribute.","title":"GetValidJsonMixin"},{"location":"api-guid/views/aiohttp/#get_valid_json","text":"This method retrieves from the request all the data that the user sent. Serializes and validates them and returns as a dictionary. Signature: .get_valid_json(parse_query=False, raise_exception=True) -> dict parse_query(bool) - Parse query params? raise_exception(bool) - Raise exception ValidationError , if validation error. Example: from rest_framework.views.aiohttp import AioHTTPApiView, GetValidJsonMixin class MyView(AioHTTPApiView, GetValidJsonMixin): serializer_classes = { 'get': MySerializer() } async def get(self): request_data = await self.get_valid_json() ############# ### Equivalent to ############# from rest_framework.views.aiohttp import AioHTTPApiView from rest_framework.views.mixins import GetSerializerMixin class MyView(AioHTTPApiView, GetSerializerMixin): async def get(self): serializer_class = self.get_request_serializer() try: data = await self.request_object.json() except Exception: data = {} ser = serializer_class(data=data) ser.is_valid(raise_exception=True) request_data = ser.validated_data","title":".get_valid_json()"},{"location":"api-guid/views/aiohttp/#aiohttpgenericviews","text":"GenericViews are ready-to-use classes, compiled from base classes and mixins for various needs.","title":"AioHttpGenericViews"},{"location":"api-guid/views/aiohttp/#getserializerapigenericview","text":"Generic Api view for GetSerializer methods. Parents: rest_framework.views.aiohttp.AioHTTPApiView rest_framework.views.mixins.GetSerializer","title":"GetSerializerApiGenericView"},{"location":"api-guid/views/aiohttp/#getresponseapigenericview","text":"Generic Api view for GetResponse methods. Parents: rest_framework.views.aiohttp.AioHTTPApiView rest_framework.views.mixins.GetResponse","title":"GetResponseApiGenericView"},{"location":"api-guid/views/aiohttp/#getvalidjsonapigenericview","text":"Generic Api view for GetValidJson methods. Parents: rest_framework.views.aiohttp.AioHTTPApiView rest_framework.views.aiohttp.mixins.GetValidJson","title":"GetValidJsonApiGenericView"},{"location":"api-guid/views/aiohttp/#apigenericview","text":"Generic Api view for all mixins methods. Parents: rest_framework.views.aiohttp.AioHTTPApiView rest_framework.views.aiohttp.mixins.GetValidJson rest_framework.views.mixins.GetSerializer rest_framework.views.mixins.GetResponse","title":"ApiGenericView"},{"location":"api-guid/views/flask/","text":"Flask Views Flask has two BaseClassViews : View , MethodView . Python-Rest-Framework is connected to both. Note: To use FlaskViews you need to install Flask . All Classes can be found here: from rest_framework.views.flask import * FlaskBaseViews FlaskBaseApiView This class is a successor: flask.views.View , rest_framework.views.BaseApiView . What the class consists of: The class is completely safe. The class does not completely change the source code of Flask, and does not restrict from the source functions of the framework. Class implemented properties: request_object , current_request_method . Using the rest_framework.views.BaseApiView._dispatch method is configured and can be adjusted by setting the use_dispatch . By default use_dispatch set in True . The class itself uses response_class=json_response : from flask import jsonify, make_response def json_response(data, status=200, content_type='application/json'): return make_response(jsonify(data), status, content_type=content_type) Example: from rest_framework.views.flask import FlaskBaseApiView class MyView(FlaskBaseApiView): def dispatch_request(self, *args, **kwargs): # your view code FlaskBaseMethodView This class is a successor: flask.views.MethodView , rest_framework.views.BaseApiView . What the class consists of: The class is completely safe. The class does not completely change the source code of Flask, and does not restrict from the source functions of the framework. Class implemented properties: request_object , current_request_method . Using the rest_framework.views.BaseApiView._dispatch method is configured and can be adjusted by setting the use_dispatch . By default use_dispatch set in True . The class itself uses response_class=json_response : from flask import jsonify, make_response def json_response(data, status=200, content_type='application/json'): return make_response(jsonify(data), status, content_type=content_type) Example: from rest_framework.views.flask import FlaskBaseMethodView class MyView(FlaskBaseMethodView): def get(self): # your view code Flask Mixins Mixins for Flask \u200b\u200bare the same useful mixins as rest_framework.views.mixins , but they can only be used in Flask . GetValidJsonMixin The class is successor: rest_framework.views.GetSerializerMixin Mixin adds the .get_valid_json() method, which parses the query and body of the query, merges them, and automatically serializes it and validates it with rest_framework.serializers.Serializer . You can describe the serializers themselves in the serializers_classes class attribute. .get_valid_json() This method retrieves from the request all the data that the user sent. Serializes and validates them and returns as a dictionary. Signature: .get_valid_json(parse_query=False, raise_exception=True) -> dict parse_query(bool) - Parse query params? raise_exception(bool) - Raise exception ValidationError , if validation error. Example: from rest_framework.views.flask import FlaskBaseMethodView, GetValidJsonMixin class MyView(FlaskBaseMethodView, GetValidJsonMixin): serializer_classes = { 'get': MySerializer() } def get(self): request_data = self.get_valid_json() ############# ### Equivalent to ############# from rest_framework.views.flask import FlaskBaseMethodView from rest_framework.views.mixins import GetSerializerMixin class MyView(FlaskBaseMethodView, GetSerializerMixin): def get(self): serializer_class = self.get_request_serializer() try: data = self.request_object.get_json() except Exception: data = {} ser = serializer_class(data=data) ser.is_valid(raise_exception=True) request_data = ser.validated_data FlaskGenericViews GenericViews are ready-to-use classes, compiled from base classes and mixins for various needs. GetSerializerApiGenericView Generic Api view for GetSerializer methods. Parents: rest_framework.views.flask.FlaskBaseApiView rest_framework.views.mixins.GetSerializer GetResponseApiGenericView Generic Api view for GetResponse methods. Parents: rest_framework.views.flask.FlaskBaseApiView rest_framework.views.mixins.GetResponse GetValidJsonApiGenericView Generic Api view for GetValidJson methods. Parents: rest_framework.views.flask.FlaskBaseApiView rest_framework.views.flask.mixins.GetValidJson ApiGenericView Generic Api view for all mixins methods. Parents: rest_framework.views.flask.FlaskBaseApiView rest_framework.views.flask.mixins.GetValidJson rest_framework.views.mixins.GetSerializer rest_framework.views.mixins.GetResponse GetSerializerApiGenericMethodView Generic Api method view for GetSerializer methods. Parents: rest_framework.views.flask.FlaskBaseMethodView rest_framework.views.mixins.GetSerializer GetResponseApiGenericMethodView Generic Api method view for GetResponse methods. Parents: rest_framework.views.flask.FlaskBaseMethodView rest_framework.views.mixins.GetResponse GetValidJsonApiGenericMethodView Generic Api method view for GetValidJson methods. Parents: rest_framework.views.flask.FlaskBaseMethodView rest_framework.views.flask.mixins.GetValidJson ApiGenericMethodView Generic Api method view for all mixins methods. Parents: rest_framework.views.flask.FlaskBaseMethodView rest_framework.views.flask.mixins.GetValidJson rest_framework.views.mixins.GetSerializer rest_framework.views.mixins.GetResponse","title":"FlaskViews"},{"location":"api-guid/views/flask/#flask-views","text":"Flask has two BaseClassViews : View , MethodView . Python-Rest-Framework is connected to both. Note: To use FlaskViews you need to install Flask . All Classes can be found here: from rest_framework.views.flask import *","title":"Flask Views"},{"location":"api-guid/views/flask/#flaskbaseviews","text":"","title":"FlaskBaseViews"},{"location":"api-guid/views/flask/#flaskbaseapiview","text":"This class is a successor: flask.views.View , rest_framework.views.BaseApiView . What the class consists of: The class is completely safe. The class does not completely change the source code of Flask, and does not restrict from the source functions of the framework. Class implemented properties: request_object , current_request_method . Using the rest_framework.views.BaseApiView._dispatch method is configured and can be adjusted by setting the use_dispatch . By default use_dispatch set in True . The class itself uses response_class=json_response : from flask import jsonify, make_response def json_response(data, status=200, content_type='application/json'): return make_response(jsonify(data), status, content_type=content_type) Example: from rest_framework.views.flask import FlaskBaseApiView class MyView(FlaskBaseApiView): def dispatch_request(self, *args, **kwargs): # your view code","title":"FlaskBaseApiView"},{"location":"api-guid/views/flask/#flaskbasemethodview","text":"This class is a successor: flask.views.MethodView , rest_framework.views.BaseApiView . What the class consists of: The class is completely safe. The class does not completely change the source code of Flask, and does not restrict from the source functions of the framework. Class implemented properties: request_object , current_request_method . Using the rest_framework.views.BaseApiView._dispatch method is configured and can be adjusted by setting the use_dispatch . By default use_dispatch set in True . The class itself uses response_class=json_response : from flask import jsonify, make_response def json_response(data, status=200, content_type='application/json'): return make_response(jsonify(data), status, content_type=content_type) Example: from rest_framework.views.flask import FlaskBaseMethodView class MyView(FlaskBaseMethodView): def get(self): # your view code","title":"FlaskBaseMethodView"},{"location":"api-guid/views/flask/#flask-mixins","text":"Mixins for Flask \u200b\u200bare the same useful mixins as rest_framework.views.mixins , but they can only be used in Flask .","title":"Flask Mixins"},{"location":"api-guid/views/flask/#getvalidjsonmixin","text":"The class is successor: rest_framework.views.GetSerializerMixin Mixin adds the .get_valid_json() method, which parses the query and body of the query, merges them, and automatically serializes it and validates it with rest_framework.serializers.Serializer . You can describe the serializers themselves in the serializers_classes class attribute.","title":"GetValidJsonMixin"},{"location":"api-guid/views/flask/#get_valid_json","text":"This method retrieves from the request all the data that the user sent. Serializes and validates them and returns as a dictionary. Signature: .get_valid_json(parse_query=False, raise_exception=True) -> dict parse_query(bool) - Parse query params? raise_exception(bool) - Raise exception ValidationError , if validation error. Example: from rest_framework.views.flask import FlaskBaseMethodView, GetValidJsonMixin class MyView(FlaskBaseMethodView, GetValidJsonMixin): serializer_classes = { 'get': MySerializer() } def get(self): request_data = self.get_valid_json() ############# ### Equivalent to ############# from rest_framework.views.flask import FlaskBaseMethodView from rest_framework.views.mixins import GetSerializerMixin class MyView(FlaskBaseMethodView, GetSerializerMixin): def get(self): serializer_class = self.get_request_serializer() try: data = self.request_object.get_json() except Exception: data = {} ser = serializer_class(data=data) ser.is_valid(raise_exception=True) request_data = ser.validated_data","title":".get_valid_json()"},{"location":"api-guid/views/flask/#flaskgenericviews","text":"GenericViews are ready-to-use classes, compiled from base classes and mixins for various needs.","title":"FlaskGenericViews"},{"location":"api-guid/views/flask/#getserializerapigenericview","text":"Generic Api view for GetSerializer methods. Parents: rest_framework.views.flask.FlaskBaseApiView rest_framework.views.mixins.GetSerializer","title":"GetSerializerApiGenericView"},{"location":"api-guid/views/flask/#getresponseapigenericview","text":"Generic Api view for GetResponse methods. Parents: rest_framework.views.flask.FlaskBaseApiView rest_framework.views.mixins.GetResponse","title":"GetResponseApiGenericView"},{"location":"api-guid/views/flask/#getvalidjsonapigenericview","text":"Generic Api view for GetValidJson methods. Parents: rest_framework.views.flask.FlaskBaseApiView rest_framework.views.flask.mixins.GetValidJson","title":"GetValidJsonApiGenericView"},{"location":"api-guid/views/flask/#apigenericview","text":"Generic Api view for all mixins methods. Parents: rest_framework.views.flask.FlaskBaseApiView rest_framework.views.flask.mixins.GetValidJson rest_framework.views.mixins.GetSerializer rest_framework.views.mixins.GetResponse","title":"ApiGenericView"},{"location":"api-guid/views/flask/#getserializerapigenericmethodview","text":"Generic Api method view for GetSerializer methods. Parents: rest_framework.views.flask.FlaskBaseMethodView rest_framework.views.mixins.GetSerializer","title":"GetSerializerApiGenericMethodView"},{"location":"api-guid/views/flask/#getresponseapigenericmethodview","text":"Generic Api method view for GetResponse methods. Parents: rest_framework.views.flask.FlaskBaseMethodView rest_framework.views.mixins.GetResponse","title":"GetResponseApiGenericMethodView"},{"location":"api-guid/views/flask/#getvalidjsonapigenericmethodview","text":"Generic Api method view for GetValidJson methods. Parents: rest_framework.views.flask.FlaskBaseMethodView rest_framework.views.flask.mixins.GetValidJson","title":"GetValidJsonApiGenericMethodView"},{"location":"api-guid/views/flask/#apigenericmethodview","text":"Generic Api method view for all mixins methods. Parents: rest_framework.views.flask.FlaskBaseMethodView rest_framework.views.flask.mixins.GetValidJson rest_framework.views.mixins.GetSerializer rest_framework.views.mixins.GetResponse","title":"ApiGenericMethodView"},{"location":"api-guid/views/mixins/","text":"Views Mixins Pytthon-Rest-Framework provides views mixins, for easy customization of your API . View Mixins is a powerful Python-Rest-Framework tool, with which you can very flexibly configure only the functionality that you need. Each mixin provides its own functionality and asks for its settings. Views Mixins do not overlap in functionality, so you can use any combination of them. Views Mixins is not only common for all types of frameworks, but also specific for each framework. All Mixins can be found here: from rest_framework.views.mixins import * Mixins GetRequestAbstractMixin Basic mixin, which is an asbestos class and requires the implementation of: request_object - The class property that the query object returns. This property is used by all inherited mixins. The property requires implementation. In the base classes for frameworks, this property is already implemented and you do not need to worry. Example(Flask): from flask import request, jsonify, make_response from flask.views import View from rest_framework.views.mixins import GetRequestAbstractMixin class MyView(View, GetRequestAbstractMixin): @property def request_object(self): return request current_request_method - A class property that returns the name of the current HTTP request method. GET , POST and etc \u2026 The property requires implementation. In the base class for frameworks, this property is already implemented and you do not need to worry. Example(Flask): from flask import request, jsonify, make_response from flask.views import View from rest_framework.views.mixins import GetRequestAbstractMixin class MyView(View, GetRequestAbstractMixin): @property def current_request_method(self): return request.method GetSerializerMixin Mixin, which allows you to conveniently work with serializers. Provides methods: get_serializer , get_request_serializer , get_response_serializer . All these methods look for serializers in the class attribute serializer_classes (Dict) according to certain rules: At the first level of the dictionary, the name of the request method is GET , POST and etc: from rest_framework.views import GetSerializerMixin class ExampleView(GetSerializerMixin): serializer_classes = { 'get': None, 'post': None } Note: You must add the methods you want to use in your view. At the second level, there must be either a Serializer or another dictionary. The dictionary must consist of either one or two keys: in , out . from rest_framework.views import GetSerializerMixin class ExampleView(GetSerializerMixin): serializer_classes = { 'get': GetSerializer, 'post': { 'in': PostRequestSerializer }, 'put': { 'in': PutRequestSerializer, 'out': PutResponseSerializer } } .get_request_serializer() A method that returns a Serializer to process data from a client. from rest_framework.views import GetSerializerMixin class ExampleView(GetSerializerMixin): serializer_classes = { 'get': GetSerializer, 'post': { 'in': PostRequestSerializer }, 'put': { 'in': PutRequestSerializer, 'out': PutResponseSerializer }, 'patch': {} } def get(self): ser = self.get_request_serializer() # ser - GetSerializer def post(self): ser = self.get_request_serializer() # ser - PostRequestSerializer def put(self): ser = self.get_request_serializer() # ser - PutRequestSerializer def patch(self): ser = self.get_request_serializer() # ser - None def delete(self): ser = self.get_request_serializer() # ser - None .get_response_serializer() A method that returns a Serializer to serialize data to return to a user. For Response . from rest_framework.views import GetSerializerMixin class ExampleView(GetSerializerMixin): serializer_classes = { 'get': GetSerializer, 'post': { 'in': PostRequestSerializer }, 'put': { 'in': PutRequestSerializer, 'out': PutResponseSerializer }, 'patch': {} } def get(self): ser = self.get_response_serializer() # ser - GetSerializer def post(self): ser = self.get_response_serializer() # ser - None def put(self): ser = self.get_response_serializer() # ser - PutResponseSerializer def patch(self): ser = self.get_response_serializer() # ser - None def delete(self): ser = self.get_response_serializer() # ser - None .get_serializer() Method for search Serializer . Signature: get_serializer(key: str) key(str) - Key for search. in or out . Example: from rest_framework.views import GetSerializerMixin class ExampleView(GetSerializerMixin): serializer_classes = { 'get': GetSerializer, 'post': { 'in': PostRequestSerializer }, 'put': { 'in': PutRequestSerializer, 'out': PutResponseSerializer }, 'patch': {} } def get(self): ser = self.get_serializer('in') # ser - GetSerializer ser = self.get_serializer('out') # ser - GetSerializer def post(self): ser = self.get_serializer('in') # ser - PostRequestSerializer ser = self.get_serializer('out') # ser - None def put(self): ser = self.get_serializer('in') # ser - PutRequestSerializer ser = self.get_serializer('out') # ser - PutResponseSerializer def patch(self): ser = self.get_serializer('in') # ser - None ser = self.get_serializer('out') # ser - None def delete(self): ser = self.get_serializer('in') # ser - None ser = self.get_serializer('out') # ser - None GetResponseMixin Mixin for easy response to the client. Attributes: response_class - Response class, for create Response. Interface: data: Any(For JSON), status: int = response status, content_type: str = application/json pagination_class - Paginator class for get pagination json. Default: LimitOffsetObjectsPaginator . Read more in the section on pagination . response_content_type - Response Content Type, default: application/json .get_response() Formation and preparation of response Response object for the client. Signature: .get_response(obj=None, is_serialized=True, status_code=200) obj(Any) - Object for response body. is_serialized(bool) - Is data serialization required? Use get_response_serializer() for serilization result object? Default: True . status_code(int) - Code server response. Default: 200 . Example(AioHTTP): from aiohttp.web import View, json_response from rest_framework.views import GetResponseMixin class ExampleView(View, GetResponseMixin): response_class = json_response serializer_classes = { 'get': MyGetSerializer } async def get(self): # Your code data = MyModel() return self.get_response(data, is_serialized=True, status_code=200) .get_list_response() Formation and preparation of response Many Response objects for the client. Signature: get_list_response(obj=None, is_serialized=True, status_code=200, *args, **kwargs) objs(List[Any]) - List Objects for response body. is_serialized(bool) - Is data serialization required? Use get_response_serializer() for serilization result object? Default: True . status_code(int) - Code server response. Default: 200 . args, kwargs - Arguments for pagination class. Read more in the section on pagination . Example(AioHTTP): from aiohttp.web import View, json_response from rest_framework.views import GetResponseMixin class ExampleView(View, GetResponseMixin): response_class = json_response serializer_classes = { 'get': MyGetSerializer } async def get(self): # Your code data = [MyModel(), MyModel(), MyModel()] return self.get_list_response(data, is_serialized=True, status_code=200) Writing custom FrameworkBaseView To write your Mixin, you can inherit from GetRequestAbstractMixin if you need the properties request_object , request_object_method . From any other Mixin , if you need its methods or attributes. And from object , if your Mixin does not depend on the existing ones. Example: class CustomHeadersMixin(object): def update_headers(self, headers): headers.update({'Custom-Auth-Header': 'HashCode'}) return headers","title":"ViewsMixins"},{"location":"api-guid/views/mixins/#views-mixins","text":"Pytthon-Rest-Framework provides views mixins, for easy customization of your API . View Mixins is a powerful Python-Rest-Framework tool, with which you can very flexibly configure only the functionality that you need. Each mixin provides its own functionality and asks for its settings. Views Mixins do not overlap in functionality, so you can use any combination of them. Views Mixins is not only common for all types of frameworks, but also specific for each framework. All Mixins can be found here: from rest_framework.views.mixins import *","title":"Views Mixins"},{"location":"api-guid/views/mixins/#mixins","text":"","title":"Mixins"},{"location":"api-guid/views/mixins/#getrequestabstractmixin","text":"Basic mixin, which is an asbestos class and requires the implementation of: request_object - The class property that the query object returns. This property is used by all inherited mixins. The property requires implementation. In the base classes for frameworks, this property is already implemented and you do not need to worry. Example(Flask): from flask import request, jsonify, make_response from flask.views import View from rest_framework.views.mixins import GetRequestAbstractMixin class MyView(View, GetRequestAbstractMixin): @property def request_object(self): return request current_request_method - A class property that returns the name of the current HTTP request method. GET , POST and etc \u2026 The property requires implementation. In the base class for frameworks, this property is already implemented and you do not need to worry. Example(Flask): from flask import request, jsonify, make_response from flask.views import View from rest_framework.views.mixins import GetRequestAbstractMixin class MyView(View, GetRequestAbstractMixin): @property def current_request_method(self): return request.method","title":"GetRequestAbstractMixin"},{"location":"api-guid/views/mixins/#getserializermixin","text":"Mixin, which allows you to conveniently work with serializers. Provides methods: get_serializer , get_request_serializer , get_response_serializer . All these methods look for serializers in the class attribute serializer_classes (Dict) according to certain rules: At the first level of the dictionary, the name of the request method is GET , POST and etc: from rest_framework.views import GetSerializerMixin class ExampleView(GetSerializerMixin): serializer_classes = { 'get': None, 'post': None } Note: You must add the methods you want to use in your view. At the second level, there must be either a Serializer or another dictionary. The dictionary must consist of either one or two keys: in , out . from rest_framework.views import GetSerializerMixin class ExampleView(GetSerializerMixin): serializer_classes = { 'get': GetSerializer, 'post': { 'in': PostRequestSerializer }, 'put': { 'in': PutRequestSerializer, 'out': PutResponseSerializer } }","title":"GetSerializerMixin"},{"location":"api-guid/views/mixins/#get_request_serializer","text":"A method that returns a Serializer to process data from a client. from rest_framework.views import GetSerializerMixin class ExampleView(GetSerializerMixin): serializer_classes = { 'get': GetSerializer, 'post': { 'in': PostRequestSerializer }, 'put': { 'in': PutRequestSerializer, 'out': PutResponseSerializer }, 'patch': {} } def get(self): ser = self.get_request_serializer() # ser - GetSerializer def post(self): ser = self.get_request_serializer() # ser - PostRequestSerializer def put(self): ser = self.get_request_serializer() # ser - PutRequestSerializer def patch(self): ser = self.get_request_serializer() # ser - None def delete(self): ser = self.get_request_serializer() # ser - None","title":".get_request_serializer()"},{"location":"api-guid/views/mixins/#get_response_serializer","text":"A method that returns a Serializer to serialize data to return to a user. For Response . from rest_framework.views import GetSerializerMixin class ExampleView(GetSerializerMixin): serializer_classes = { 'get': GetSerializer, 'post': { 'in': PostRequestSerializer }, 'put': { 'in': PutRequestSerializer, 'out': PutResponseSerializer }, 'patch': {} } def get(self): ser = self.get_response_serializer() # ser - GetSerializer def post(self): ser = self.get_response_serializer() # ser - None def put(self): ser = self.get_response_serializer() # ser - PutResponseSerializer def patch(self): ser = self.get_response_serializer() # ser - None def delete(self): ser = self.get_response_serializer() # ser - None","title":".get_response_serializer()"},{"location":"api-guid/views/mixins/#get_serializer","text":"Method for search Serializer . Signature: get_serializer(key: str) key(str) - Key for search. in or out . Example: from rest_framework.views import GetSerializerMixin class ExampleView(GetSerializerMixin): serializer_classes = { 'get': GetSerializer, 'post': { 'in': PostRequestSerializer }, 'put': { 'in': PutRequestSerializer, 'out': PutResponseSerializer }, 'patch': {} } def get(self): ser = self.get_serializer('in') # ser - GetSerializer ser = self.get_serializer('out') # ser - GetSerializer def post(self): ser = self.get_serializer('in') # ser - PostRequestSerializer ser = self.get_serializer('out') # ser - None def put(self): ser = self.get_serializer('in') # ser - PutRequestSerializer ser = self.get_serializer('out') # ser - PutResponseSerializer def patch(self): ser = self.get_serializer('in') # ser - None ser = self.get_serializer('out') # ser - None def delete(self): ser = self.get_serializer('in') # ser - None ser = self.get_serializer('out') # ser - None","title":".get_serializer()"},{"location":"api-guid/views/mixins/#getresponsemixin","text":"Mixin for easy response to the client. Attributes: response_class - Response class, for create Response. Interface: data: Any(For JSON), status: int = response status, content_type: str = application/json pagination_class - Paginator class for get pagination json. Default: LimitOffsetObjectsPaginator . Read more in the section on pagination . response_content_type - Response Content Type, default: application/json","title":"GetResponseMixin"},{"location":"api-guid/views/mixins/#get_response","text":"Formation and preparation of response Response object for the client. Signature: .get_response(obj=None, is_serialized=True, status_code=200) obj(Any) - Object for response body. is_serialized(bool) - Is data serialization required? Use get_response_serializer() for serilization result object? Default: True . status_code(int) - Code server response. Default: 200 . Example(AioHTTP): from aiohttp.web import View, json_response from rest_framework.views import GetResponseMixin class ExampleView(View, GetResponseMixin): response_class = json_response serializer_classes = { 'get': MyGetSerializer } async def get(self): # Your code data = MyModel() return self.get_response(data, is_serialized=True, status_code=200)","title":".get_response()"},{"location":"api-guid/views/mixins/#get_list_response","text":"Formation and preparation of response Many Response objects for the client. Signature: get_list_response(obj=None, is_serialized=True, status_code=200, *args, **kwargs) objs(List[Any]) - List Objects for response body. is_serialized(bool) - Is data serialization required? Use get_response_serializer() for serilization result object? Default: True . status_code(int) - Code server response. Default: 200 . args, kwargs - Arguments for pagination class. Read more in the section on pagination . Example(AioHTTP): from aiohttp.web import View, json_response from rest_framework.views import GetResponseMixin class ExampleView(View, GetResponseMixin): response_class = json_response serializer_classes = { 'get': MyGetSerializer } async def get(self): # Your code data = [MyModel(), MyModel(), MyModel()] return self.get_list_response(data, is_serialized=True, status_code=200)","title":".get_list_response()"},{"location":"api-guid/views/mixins/#writing-custom-frameworkbaseview","text":"To write your Mixin, you can inherit from GetRequestAbstractMixin if you need the properties request_object , request_object_method . From any other Mixin , if you need its methods or attributes. And from object , if your Mixin does not depend on the existing ones. Example: class CustomHeadersMixin(object): def update_headers(self, headers): headers.update({'Custom-Auth-Header': 'HashCode'}) return headers","title":"Writing custom FrameworkBaseView"},{"location":"api-guid/views/paginations/","text":"Pagination Python-Rest-Framework provides classes for pagination. These classes are used directly in GetResponseMixin . But they can be used independently for any purpose. Classes themselves do not perform pagination, they only form the correct JSON , for the correct response to the client. All Mixins can be found here: from rest_framework.views.paginations import * Paginator Classes Full classes for pagination. Paginators accept the data themselves in their constructor. Then the .paginate() method is called, which accepts the arguments defined for the current Paginator . And this method returns a ready-made JSON . Paginator consists of three methods: .get_paginate_data() , .get_objects_data() , .paginate() .get_paginate_data() Abstract Method This method adds information about the pagination itself. Must return a dictionary with data. Signature: .get_paginate_data(*args, **kwargs) -> dict args, kwargs - Your custom data for pagination. .get_objects_data() Abstract Method This method adds information on the objects themselves from the list. Must return a dictionary with data. Signature: .get_objects_data() -> dict .paginate() This method generates complete JSON with data. Takes the same arguments as .get_paginate_data() and sends them to it. Must return a dictionary with data. Signature: .paginate() -> dict LimitOffsetResultPaginator Paginator with limit , offset , count , result parameters. Example: from rest_framework.views.paginations import LimitOffsetResultPaginator all_objects = list(range(100)) current_page = all_objects[:10] result = LimitOffsetResultPaginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'result': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]} LimitOffsetObjectsPaginator Paginator with limit , offset , count , objects parameters. Example: from rest_framework.views.paginations import LimitOffsetObjectsPaginator all_objects = list(range(100)) current_page = all_objects[:10] result = LimitOffsetObjectsPaginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'objects': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]} LimitOffsetItemsPaginator Paginator with limit , offset , count , items parameters. Example: from rest_framework.views.paginations import LimitOffsetItemsPaginator all_objects = list(range(100)) current_page = all_objects[:10] result = LimitOffsetItemsPaginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'items': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]} Paginator Mixins Mixins for create Paginators . LimitOffsetGetPaginateDataMixin Mixin for added to result JSON limit , offset , count fields. Example: from rest_framework.views.paginations import BasePaginatorAbstract, LimitOffsetGetPaginateDataMixin class Paginator(BasePaginatorAbstract, LimitOffsetGetPaginateDataMixin): def get_objects_data(self): return {'paginator': self.objects} all_objects = list(range(100)) current_page = all_objects[:10] result = Paginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'paginator': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]} ResultGetObjectsDataPaginatorMixin Mixin for added to result JSON result fields. Example: from rest_framework.views.paginations import BasePaginatorAbstract, ResultGetObjectsDataPaginatorMixin class Paginator(BasePaginatorAbstract, ResultGetObjectsDataPaginatorMixin): def get_paginate_data(self, limit=10, offset=0, count=None): return dict(limit=limit, offset=offset, count=count) all_objects = list(range(100)) current_page = all_objects[:10] result = Paginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'result': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]} ObjectsGetObjectsDataPaginatorMixin Mixin for added to result JSON objects fields. Example: from rest_framework.views.paginations import BasePaginatorAbstract, ObjectsGetObjectsDataPaginatorMixin class Paginator(BasePaginatorAbstract, ObjectsGetObjectsDataPaginatorMixin): def get_paginate_data(self, limit=10, offset=0, count=None): return dict(limit=limit, offset=offset, count=count) all_objects = list(range(100)) current_page = all_objects[:10] result = Paginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'objects': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]} ItemsGetObjectsDataPaginatorMixin Mixin for added to result JSON items fields. Example: from rest_framework.views.paginations import BasePaginatorAbstract, ItemsGetObjectsDataPaginatorMixin class Paginator(BasePaginatorAbstract, ItemsGetObjectsDataPaginatorMixin): def get_paginate_data(self, limit=10, offset=0, count=None): return dict(limit=limit, offset=offset, count=count) all_objects = list(range(100)) current_page = all_objects[:10] result = Paginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'items': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]} Writing custom Paginator Inherit the rest_framework.views.paginations.BasePaginatorAbstract class and define the methods: .get_paginate_data(*args,**kwargs) , .get_objects_data() . The very slice of objects is in self.objects . Example: from rest_framework.views.paginations import BasePaginatorAbstract class MyPaginator(BasePaginatorAbstract): def get_paginate_data(self, after=0, before=10, total=10): return dict(after=after, total=total) def get_objects_data(self): return dict(object=self.objects) all_objects = list(range(100)) current_page = all_objects[:10] result = MyPaginator(all_objects).paginate(after=10, total=10) print(result) # {'after': 10, 'total': 10, 'objects': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}","title":"PaginationViews"},{"location":"api-guid/views/paginations/#pagination","text":"Python-Rest-Framework provides classes for pagination. These classes are used directly in GetResponseMixin . But they can be used independently for any purpose. Classes themselves do not perform pagination, they only form the correct JSON , for the correct response to the client. All Mixins can be found here: from rest_framework.views.paginations import *","title":"Pagination"},{"location":"api-guid/views/paginations/#paginator-classes","text":"Full classes for pagination. Paginators accept the data themselves in their constructor. Then the .paginate() method is called, which accepts the arguments defined for the current Paginator . And this method returns a ready-made JSON . Paginator consists of three methods: .get_paginate_data() , .get_objects_data() , .paginate()","title":"Paginator Classes"},{"location":"api-guid/views/paginations/#get_paginate_data","text":"Abstract Method This method adds information about the pagination itself. Must return a dictionary with data. Signature: .get_paginate_data(*args, **kwargs) -> dict args, kwargs - Your custom data for pagination.","title":".get_paginate_data()"},{"location":"api-guid/views/paginations/#get_objects_data","text":"Abstract Method This method adds information on the objects themselves from the list. Must return a dictionary with data. Signature: .get_objects_data() -> dict","title":".get_objects_data()"},{"location":"api-guid/views/paginations/#paginate","text":"This method generates complete JSON with data. Takes the same arguments as .get_paginate_data() and sends them to it. Must return a dictionary with data. Signature: .paginate() -> dict","title":".paginate()"},{"location":"api-guid/views/paginations/#limitoffsetresultpaginator","text":"Paginator with limit , offset , count , result parameters. Example: from rest_framework.views.paginations import LimitOffsetResultPaginator all_objects = list(range(100)) current_page = all_objects[:10] result = LimitOffsetResultPaginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'result': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}","title":"LimitOffsetResultPaginator"},{"location":"api-guid/views/paginations/#limitoffsetobjectspaginator","text":"Paginator with limit , offset , count , objects parameters. Example: from rest_framework.views.paginations import LimitOffsetObjectsPaginator all_objects = list(range(100)) current_page = all_objects[:10] result = LimitOffsetObjectsPaginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'objects': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}","title":"LimitOffsetObjectsPaginator"},{"location":"api-guid/views/paginations/#limitoffsetitemspaginator","text":"Paginator with limit , offset , count , items parameters. Example: from rest_framework.views.paginations import LimitOffsetItemsPaginator all_objects = list(range(100)) current_page = all_objects[:10] result = LimitOffsetItemsPaginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'items': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}","title":"LimitOffsetItemsPaginator"},{"location":"api-guid/views/paginations/#paginator-mixins","text":"Mixins for create Paginators .","title":"Paginator Mixins"},{"location":"api-guid/views/paginations/#limitoffsetgetpaginatedatamixin","text":"Mixin for added to result JSON limit , offset , count fields. Example: from rest_framework.views.paginations import BasePaginatorAbstract, LimitOffsetGetPaginateDataMixin class Paginator(BasePaginatorAbstract, LimitOffsetGetPaginateDataMixin): def get_objects_data(self): return {'paginator': self.objects} all_objects = list(range(100)) current_page = all_objects[:10] result = Paginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'paginator': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}","title":"LimitOffsetGetPaginateDataMixin"},{"location":"api-guid/views/paginations/#resultgetobjectsdatapaginatormixin","text":"Mixin for added to result JSON result fields. Example: from rest_framework.views.paginations import BasePaginatorAbstract, ResultGetObjectsDataPaginatorMixin class Paginator(BasePaginatorAbstract, ResultGetObjectsDataPaginatorMixin): def get_paginate_data(self, limit=10, offset=0, count=None): return dict(limit=limit, offset=offset, count=count) all_objects = list(range(100)) current_page = all_objects[:10] result = Paginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'result': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}","title":"ResultGetObjectsDataPaginatorMixin"},{"location":"api-guid/views/paginations/#objectsgetobjectsdatapaginatormixin","text":"Mixin for added to result JSON objects fields. Example: from rest_framework.views.paginations import BasePaginatorAbstract, ObjectsGetObjectsDataPaginatorMixin class Paginator(BasePaginatorAbstract, ObjectsGetObjectsDataPaginatorMixin): def get_paginate_data(self, limit=10, offset=0, count=None): return dict(limit=limit, offset=offset, count=count) all_objects = list(range(100)) current_page = all_objects[:10] result = Paginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'objects': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}","title":"ObjectsGetObjectsDataPaginatorMixin"},{"location":"api-guid/views/paginations/#itemsgetobjectsdatapaginatormixin","text":"Mixin for added to result JSON items fields. Example: from rest_framework.views.paginations import BasePaginatorAbstract, ItemsGetObjectsDataPaginatorMixin class Paginator(BasePaginatorAbstract, ItemsGetObjectsDataPaginatorMixin): def get_paginate_data(self, limit=10, offset=0, count=None): return dict(limit=limit, offset=offset, count=count) all_objects = list(range(100)) current_page = all_objects[:10] result = Paginator(all_objects).paginate(limit=10, offset=0, count=100) print(result) # {'limit': 10, 'offset': 0, 'count': 100, 'items': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}","title":"ItemsGetObjectsDataPaginatorMixin"},{"location":"api-guid/views/paginations/#writing-custom-paginator","text":"Inherit the rest_framework.views.paginations.BasePaginatorAbstract class and define the methods: .get_paginate_data(*args,**kwargs) , .get_objects_data() . The very slice of objects is in self.objects . Example: from rest_framework.views.paginations import BasePaginatorAbstract class MyPaginator(BasePaginatorAbstract): def get_paginate_data(self, after=0, before=10, total=10): return dict(after=after, total=total) def get_objects_data(self): return dict(object=self.objects) all_objects = list(range(100)) current_page = all_objects[:10] result = MyPaginator(all_objects).paginate(after=10, total=10) print(result) # {'after': 10, 'total': 10, 'objects': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}","title":"Writing custom Paginator"},{"location":"api-guid/views/sanic/","text":"Sanic Views Sanic has two BaseClassViews : HTTPMethodView , CompositionView . Python-Rest-Framework is connected to both. Note: To use SanicViews you need to install sanic . All Classes can be found here: from rest_framework.views.sanic import * SanicBaseViews SanicApiMethodView This class is a successor: sanic.views.HTTPMethodView , rest_framework.views.BaseApiView . What the class consists of: The class is completely safe. The class does not completely change the source code of Flask, and does not restrict from the source functions of the framework. Class implemented properties: request_object , current_request_method . Using the rest_framework.views.BaseApiView._dispatch method is configured and can be adjusted by setting the use_dispatch . By default use_dispatch set in True . For current work, added self._request attribute. The class itself uses response_class=json_response : from sanic import response json_response = response.json Example: from rest_framework.views.sanic import SanicApiMethodView class MyView(SanicApiMethodView): def get(self, request, *args, **kwargs): # your view code SanicApiCompositionView This class is a successor: sanic.views.SanicApiCompositionView , rest_framework.views.BaseApiView . What the class consists of: The class is completely safe. The class does not completely change the source code of Flask, and does not restrict from the source functions of the framework. Class implemented properties: request_object , current_request_method . Using the rest_framework.views.BaseApiView._dispatch method is configured and can be adjusted by setting the use_dispatch . By default use_dispatch set in True . For current work, added self._request attribute. The class itself uses response_class=json_response : from sanic import response json_response = response.json Example: from sanic.response import text from rest_framework.views.sanic import SanicApiCompositionView class MyCompositionView(SanicApiCompositionView): def get_handler(self, request): return text('I am a get method') view = MyCompositionView() view.add(['GET'], view.get_handler) Sanic Mixins Mixins for Sanic \u200b\u200bare the same useful mixins as rest_framework.views.mixins , but they can only be used in Sanic . GetValidJsonMixin The class is successor: rest_framework.views.GetSerializerMixin Mixin adds the .get_valid_json() method, which parses the query and body of the query, merges them, and automatically serializes it and validates it with rest_framework.serializers.Serializer . You can describe the serializers themselves in the serializers_classes class attribute. .get_valid_json() This method retrieves from the request all the data that the user sent. Serializes and validates them and returns as a dictionary. Signature: .get_valid_json(parse_query=False, raise_exception=True) -> dict parse_query(bool) - Parse query params? raise_exception(bool) - Raise exception ValidationError , if validation error. Example: from rest_framework.views.sanic import SanicApiMethodView, GetValidJsonMixin class MyView(SanicApiMethodView, GetValidJsonMixin): serializer_classes = { 'get': MySerializer() } def get(self, request, *args, **kwargs): request_data = self.get_valid_json() ############# ### Equivalent to ############# from rest_framework.views.sanic import SanicApiMethodView from rest_framework.views.mixins import GetSerializerMixin class MyView(SanicApiMethodView, GetSerializerMixin): def get(self, request, *args, **kwargs): serializer_class = self.get_request_serializer() try: data = self.request_object.json except Exception: data = {} ser = serializer_class(data=data) ser.is_valid(raise_exception=True) request_data = ser.validated_data SanicGenericViews GenericViews are ready-to-use classes, compiled from base classes and mixins for various needs. GetSerializerApiGenericMethodView Generic Api method view for GetSerializer methods. Parents: rest_framework.views.sanic.SanicApiMethodView rest_framework.views.mixins.GetSerializer GetResponseApiGenericMethodView Generic Api method view for GetResponse methods. Parents: rest_framework.views.sanic.SanicApiMethodView rest_framework.views.mixins.GetResponse GetValidJsonApiGenericMethodView Generic Api method view for GetValidJson methods. Parents: rest_framework.views.sanic.SanicApiMethodView rest_framework.views.sanic.mixins.GetValidJson ApiGenericMethodView Generic Api method view for all mixins methods. Parents: rest_framework.views.sanic.SanicApiMethodView rest_framework.views.sanic.mixins.GetValidJson rest_framework.views.mixins.GetSerializer rest_framework.views.mixins.GetResponse GetSerializerApiGenericCompositionView Generic Api composition view for GetSerializer methods. Parents: rest_framework.views.sanic.SanicApiCompositionView rest_framework.views.mixins.GetSerializer GetResponseApiGenericCompositionView Generic Api composition view for GetResponse methods. Parents: rest_framework.views.sanic.SanicApiCompositionView rest_framework.views.mixins.GetResponse GetValidJsonApiGenericCompositionView Generic Api composition view for GetValidJson methods. Parents: rest_framework.views.sanic.SanicApiCompositionView rest_framework.views.sanic.mixins.GetValidJson ApiGenericCompositionView Generic Api composition view for all mixins methods. Parents: rest_framework.views.sanic.SanicApiCompositionView rest_framework.views.sanic.mixins.GetValidJson rest_framework.views.mixins.GetSerializer rest_framework.views.mixins.GetResponse","title":"SanicViews"},{"location":"api-guid/views/sanic/#sanic-views","text":"Sanic has two BaseClassViews : HTTPMethodView , CompositionView . Python-Rest-Framework is connected to both. Note: To use SanicViews you need to install sanic . All Classes can be found here: from rest_framework.views.sanic import *","title":"Sanic Views"},{"location":"api-guid/views/sanic/#sanicbaseviews","text":"","title":"SanicBaseViews"},{"location":"api-guid/views/sanic/#sanicapimethodview","text":"This class is a successor: sanic.views.HTTPMethodView , rest_framework.views.BaseApiView . What the class consists of: The class is completely safe. The class does not completely change the source code of Flask, and does not restrict from the source functions of the framework. Class implemented properties: request_object , current_request_method . Using the rest_framework.views.BaseApiView._dispatch method is configured and can be adjusted by setting the use_dispatch . By default use_dispatch set in True . For current work, added self._request attribute. The class itself uses response_class=json_response : from sanic import response json_response = response.json Example: from rest_framework.views.sanic import SanicApiMethodView class MyView(SanicApiMethodView): def get(self, request, *args, **kwargs): # your view code","title":"SanicApiMethodView"},{"location":"api-guid/views/sanic/#sanicapicompositionview","text":"This class is a successor: sanic.views.SanicApiCompositionView , rest_framework.views.BaseApiView . What the class consists of: The class is completely safe. The class does not completely change the source code of Flask, and does not restrict from the source functions of the framework. Class implemented properties: request_object , current_request_method . Using the rest_framework.views.BaseApiView._dispatch method is configured and can be adjusted by setting the use_dispatch . By default use_dispatch set in True . For current work, added self._request attribute. The class itself uses response_class=json_response : from sanic import response json_response = response.json Example: from sanic.response import text from rest_framework.views.sanic import SanicApiCompositionView class MyCompositionView(SanicApiCompositionView): def get_handler(self, request): return text('I am a get method') view = MyCompositionView() view.add(['GET'], view.get_handler)","title":"SanicApiCompositionView"},{"location":"api-guid/views/sanic/#sanic-mixins","text":"Mixins for Sanic \u200b\u200bare the same useful mixins as rest_framework.views.mixins , but they can only be used in Sanic .","title":"Sanic Mixins"},{"location":"api-guid/views/sanic/#getvalidjsonmixin","text":"The class is successor: rest_framework.views.GetSerializerMixin Mixin adds the .get_valid_json() method, which parses the query and body of the query, merges them, and automatically serializes it and validates it with rest_framework.serializers.Serializer . You can describe the serializers themselves in the serializers_classes class attribute.","title":"GetValidJsonMixin"},{"location":"api-guid/views/sanic/#get_valid_json","text":"This method retrieves from the request all the data that the user sent. Serializes and validates them and returns as a dictionary. Signature: .get_valid_json(parse_query=False, raise_exception=True) -> dict parse_query(bool) - Parse query params? raise_exception(bool) - Raise exception ValidationError , if validation error. Example: from rest_framework.views.sanic import SanicApiMethodView, GetValidJsonMixin class MyView(SanicApiMethodView, GetValidJsonMixin): serializer_classes = { 'get': MySerializer() } def get(self, request, *args, **kwargs): request_data = self.get_valid_json() ############# ### Equivalent to ############# from rest_framework.views.sanic import SanicApiMethodView from rest_framework.views.mixins import GetSerializerMixin class MyView(SanicApiMethodView, GetSerializerMixin): def get(self, request, *args, **kwargs): serializer_class = self.get_request_serializer() try: data = self.request_object.json except Exception: data = {} ser = serializer_class(data=data) ser.is_valid(raise_exception=True) request_data = ser.validated_data","title":".get_valid_json()"},{"location":"api-guid/views/sanic/#sanicgenericviews","text":"GenericViews are ready-to-use classes, compiled from base classes and mixins for various needs.","title":"SanicGenericViews"},{"location":"api-guid/views/sanic/#getserializerapigenericmethodview","text":"Generic Api method view for GetSerializer methods. Parents: rest_framework.views.sanic.SanicApiMethodView rest_framework.views.mixins.GetSerializer","title":"GetSerializerApiGenericMethodView"},{"location":"api-guid/views/sanic/#getresponseapigenericmethodview","text":"Generic Api method view for GetResponse methods. Parents: rest_framework.views.sanic.SanicApiMethodView rest_framework.views.mixins.GetResponse","title":"GetResponseApiGenericMethodView"},{"location":"api-guid/views/sanic/#getvalidjsonapigenericmethodview","text":"Generic Api method view for GetValidJson methods. Parents: rest_framework.views.sanic.SanicApiMethodView rest_framework.views.sanic.mixins.GetValidJson","title":"GetValidJsonApiGenericMethodView"},{"location":"api-guid/views/sanic/#apigenericmethodview","text":"Generic Api method view for all mixins methods. Parents: rest_framework.views.sanic.SanicApiMethodView rest_framework.views.sanic.mixins.GetValidJson rest_framework.views.mixins.GetSerializer rest_framework.views.mixins.GetResponse","title":"ApiGenericMethodView"},{"location":"api-guid/views/sanic/#getserializerapigenericcompositionview","text":"Generic Api composition view for GetSerializer methods. Parents: rest_framework.views.sanic.SanicApiCompositionView rest_framework.views.mixins.GetSerializer","title":"GetSerializerApiGenericCompositionView"},{"location":"api-guid/views/sanic/#getresponseapigenericcompositionview","text":"Generic Api composition view for GetResponse methods. Parents: rest_framework.views.sanic.SanicApiCompositionView rest_framework.views.mixins.GetResponse","title":"GetResponseApiGenericCompositionView"},{"location":"api-guid/views/sanic/#getvalidjsonapigenericcompositionview","text":"Generic Api composition view for GetValidJson methods. Parents: rest_framework.views.sanic.SanicApiCompositionView rest_framework.views.sanic.mixins.GetValidJson","title":"GetValidJsonApiGenericCompositionView"},{"location":"api-guid/views/sanic/#apigenericcompositionview","text":"Generic Api composition view for all mixins methods. Parents: rest_framework.views.sanic.SanicApiCompositionView rest_framework.views.sanic.mixins.GetValidJson rest_framework.views.mixins.GetSerializer rest_framework.views.mixins.GetResponse","title":"ApiGenericCompositionView"},{"location":"api-guid/views/views/","text":"Views Pytthon-Rest-Framework provides an BaseApiView class. BaseApiView classes are different from regular View classes in the following ways: Any ApiException exceptions will be caught and mediated into appropriate responses. It can be customized. The BaseApiView class has a fail method that can return a valid JSON Response for you for an error. You configure which class Response will return. With View Mixins you can flexibly build the functionality you need for your View . Using the BaseApiView class is pretty much the same as using a regular View class, as usual, the incoming request is dispatched to an appropriate handler method such as .get() or .post() . Additionally, a number of attributes may be set on the class that control various aspects of the API policy . For example: from rest_framework.views import BaseApiView, GetSerializerMixin, GetResponseMixin from your_application.serializers import RequestSerializer, ResponseSerializer from your_web_framework.response import json_response_class class ApiView(BaseApiView, YourFrameworkApiView, GetSerializerMixin, GetResponseMixin): response_class = json_response_class serializer_classes = { 'get': { 'in': RequestSerializer, 'out': ResponseSerializer } } @property def request_object(self): return self.request @property def current_request_method(self): return self.request_object.method # type: str def get(self): ser_class = self.get_request_serializer() # From GetSerializerMixin ser = ser_class(data=self.request_object.json()) ser.is_valid(raise_exception=True) data = ser.validated_data # ... # Your data work # ... # Return valid response object and serialized {'result': 'ok'} ResponseSerializer return self.get_response({'result': 'ok'}) # From GetResponseMixin But even in this example, we had to write additional methods request_object , current_request_method . These are internal methods for GetResponseMixin to work correctly. Python-Rest-Framework took care of this, and wrote all the internal implementations for different frameworks. Consider the same thing with the help of Flask . from rest_framework.views.flask import FlaskBaseMethodView, GetValidJsonMixin from your_application.serializers import RequestSerializer, ResponseSerializer class ApiView(FlaskBaseMethodView, GetSerializerMixin, GetResponseMixin, GetValidJsonMixin): serializer_classes = { 'get': { 'in': RequestSerializer, 'out': ResponseSerializer } } def get(self): # Auto get data. data = self.get_valid_json() # From GetValidJsonMixin mixin # ... # Your data work # ... # Return valid response object and serialized {'result': 'ok'} ResponseSerializer return self.get_response({'result': 'ok'}) # From GetResponseMixin Using the BaseApiView class directly is not recommended; instead, use the base classes for your framework or GenericViews . BaseApiView Attributes These attributes allow you to customize the behavior of BaseApiView . use_dispatch - bool A flag that includes the base wrapper for all internal functions. Off by default. In all implementations for frameworks, the flag is on by default. response_class - Callable Class Response . Default is None. Each framework has its own and is already installed and configured. response_content_type - str Content response answer api. Used in methods that form Response , or raise errors API . Default: application/json . BaseApiView methods .fail() Method that throws ApiException . To interrupt the processing of the request and give the client a Response with an error. Signature: fail(detail=None, status=400) detail - Dict which will be returned to the client in Response . status - Server response status. The default is 400 . Example: from rest_framework.views.flask import FlaskBaseMethodView, GetValidJsonMixin from your_application.serializers import RequestSerializer, ResponseSerializer class ApiView(FlaskBaseMethodView, GetSerializerMixin, GetResponseMixin, GetValidJsonMixin): serializer_classes = { 'get': { 'in': RequestSerializer, 'out': ResponseSerializer } } def get(self): # Auto get data. data = self.get_valid_json() # From GetValidJsonMixin mixin # ... # Your data work # ... if data.get('not_exists_field', None) is None: self.fail('not_exists_field field is required') # Return valid response object and serialized {'result': 'ok'} ResponseSerializer return self.get_response({'result': 'ok'}) # From GetResponseMixin Writing custom FrameworkBaseView You need to inherit from rest_framework.views.BaseApiView and do some work. Implement the properties request_object , request_object_method , so that you can use Views Mixins . Wrap your view into the _dispatch method. ._dispatch() A method that adds its logic to Views . Signature: ._dispatch(method, *args, **kwargs) method(Callable) - User request handler. args, kwargs - Arguments for user request handler. Example(For Flask Framework): from flask import request, jsonify, make_response from flask.views import MethodView from rest_framework.views.base import BaseApiView def json_response(data, status=200, content_type='application/json'): return make_response(jsonify(data), status, content_type=content_type) class FlaskBaseMethodView(MethodView, BaseApiView): response_class = json_response @property def request_object(self): return request @property def current_request_method(self): return request.method def dispatch_request(self, *args, **kwargs): meth = getattr(self, request.method.lower(), None) # If the request method is HEAD and we don't have a handler for it # retry with GET. if meth is None and request.method == 'HEAD': meth = getattr(self, 'get', None) assert meth is not None, 'Unimplemented method %r' % request.method # Wrapped in a method _dispatch if self.use_dispatch: return self._dispatch(meth, *args, **kwargs) return meth(*args, **kwargs)","title":"BaseViews"},{"location":"api-guid/views/views/#views","text":"Pytthon-Rest-Framework provides an BaseApiView class. BaseApiView classes are different from regular View classes in the following ways: Any ApiException exceptions will be caught and mediated into appropriate responses. It can be customized. The BaseApiView class has a fail method that can return a valid JSON Response for you for an error. You configure which class Response will return. With View Mixins you can flexibly build the functionality you need for your View . Using the BaseApiView class is pretty much the same as using a regular View class, as usual, the incoming request is dispatched to an appropriate handler method such as .get() or .post() . Additionally, a number of attributes may be set on the class that control various aspects of the API policy . For example: from rest_framework.views import BaseApiView, GetSerializerMixin, GetResponseMixin from your_application.serializers import RequestSerializer, ResponseSerializer from your_web_framework.response import json_response_class class ApiView(BaseApiView, YourFrameworkApiView, GetSerializerMixin, GetResponseMixin): response_class = json_response_class serializer_classes = { 'get': { 'in': RequestSerializer, 'out': ResponseSerializer } } @property def request_object(self): return self.request @property def current_request_method(self): return self.request_object.method # type: str def get(self): ser_class = self.get_request_serializer() # From GetSerializerMixin ser = ser_class(data=self.request_object.json()) ser.is_valid(raise_exception=True) data = ser.validated_data # ... # Your data work # ... # Return valid response object and serialized {'result': 'ok'} ResponseSerializer return self.get_response({'result': 'ok'}) # From GetResponseMixin But even in this example, we had to write additional methods request_object , current_request_method . These are internal methods for GetResponseMixin to work correctly. Python-Rest-Framework took care of this, and wrote all the internal implementations for different frameworks. Consider the same thing with the help of Flask . from rest_framework.views.flask import FlaskBaseMethodView, GetValidJsonMixin from your_application.serializers import RequestSerializer, ResponseSerializer class ApiView(FlaskBaseMethodView, GetSerializerMixin, GetResponseMixin, GetValidJsonMixin): serializer_classes = { 'get': { 'in': RequestSerializer, 'out': ResponseSerializer } } def get(self): # Auto get data. data = self.get_valid_json() # From GetValidJsonMixin mixin # ... # Your data work # ... # Return valid response object and serialized {'result': 'ok'} ResponseSerializer return self.get_response({'result': 'ok'}) # From GetResponseMixin Using the BaseApiView class directly is not recommended; instead, use the base classes for your framework or GenericViews .","title":"Views"},{"location":"api-guid/views/views/#baseapiview-attributes","text":"These attributes allow you to customize the behavior of BaseApiView .","title":"BaseApiView Attributes"},{"location":"api-guid/views/views/#use_dispatch-bool","text":"A flag that includes the base wrapper for all internal functions. Off by default. In all implementations for frameworks, the flag is on by default.","title":"use_dispatch - bool"},{"location":"api-guid/views/views/#response_class-callable","text":"Class Response . Default is None. Each framework has its own and is already installed and configured.","title":"response_class - Callable"},{"location":"api-guid/views/views/#response_content_type-str","text":"Content response answer api. Used in methods that form Response , or raise errors API . Default: application/json .","title":"response_content_type - str"},{"location":"api-guid/views/views/#baseapiview-methods","text":"","title":"BaseApiView methods"},{"location":"api-guid/views/views/#fail","text":"Method that throws ApiException . To interrupt the processing of the request and give the client a Response with an error. Signature: fail(detail=None, status=400) detail - Dict which will be returned to the client in Response . status - Server response status. The default is 400 . Example: from rest_framework.views.flask import FlaskBaseMethodView, GetValidJsonMixin from your_application.serializers import RequestSerializer, ResponseSerializer class ApiView(FlaskBaseMethodView, GetSerializerMixin, GetResponseMixin, GetValidJsonMixin): serializer_classes = { 'get': { 'in': RequestSerializer, 'out': ResponseSerializer } } def get(self): # Auto get data. data = self.get_valid_json() # From GetValidJsonMixin mixin # ... # Your data work # ... if data.get('not_exists_field', None) is None: self.fail('not_exists_field field is required') # Return valid response object and serialized {'result': 'ok'} ResponseSerializer return self.get_response({'result': 'ok'}) # From GetResponseMixin","title":".fail()"},{"location":"api-guid/views/views/#writing-custom-frameworkbaseview","text":"You need to inherit from rest_framework.views.BaseApiView and do some work. Implement the properties request_object , request_object_method , so that you can use Views Mixins . Wrap your view into the _dispatch method.","title":"Writing custom FrameworkBaseView"},{"location":"api-guid/views/views/#_dispatch","text":"A method that adds its logic to Views . Signature: ._dispatch(method, *args, **kwargs) method(Callable) - User request handler. args, kwargs - Arguments for user request handler. Example(For Flask Framework): from flask import request, jsonify, make_response from flask.views import MethodView from rest_framework.views.base import BaseApiView def json_response(data, status=200, content_type='application/json'): return make_response(jsonify(data), status, content_type=content_type) class FlaskBaseMethodView(MethodView, BaseApiView): response_class = json_response @property def request_object(self): return request @property def current_request_method(self): return request.method def dispatch_request(self, *args, **kwargs): meth = getattr(self, request.method.lower(), None) # If the request method is HEAD and we don't have a handler for it # retry with GET. if meth is None and request.method == 'HEAD': meth = getattr(self, 'get', None) assert meth is not None, 'Unimplemented method %r' % request.method # Wrapped in a method _dispatch if self.use_dispatch: return self._dispatch(meth, *args, **kwargs) return meth(*args, **kwargs)","title":"._dispatch()"}]}